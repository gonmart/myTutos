<!DOCTYPE html>
<html>

<head>
    <title>program-velocity-metrics</title>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {

            function standardDeviation(values) {
                var avg = average(values);

                var squareDiffs = values.map(function (value) {
                    var diff = value - avg;
                    var sqrDiff = diff * diff;
                    return sqrDiff;
                });

                var avgSquareDiff = average(squareDiffs);

                var stdDev = Math.sqrt(avgSquareDiff);
                return stdDev;
            }

            function average(data) {
                var sum = data.reduce(function (sum, value) {
                    return sum + value;
                }, 0);

                var avg = sum / data.length;
                return avg;
            }


            Ext.define('Ext.chart.theme.ColumnTheme', {
                extend: 'Ext.chart.theme.Base',
                constructor: function (config) {
                    this.callParent([Ext.apply({

                        colors: ['STEELBLUE', 'seagreen']

                    }, config)]);
                }
            });


            Ext.define('CustomApp', {
                extend: 'Rally.app.App',
                componentCls: 'app',
                items: [{
                        margins: '5 5 5 5',
                        itemId: 'chart-container',
                        layout: 'column'
                    },
                    {
                        margins: '5 5 5 5',
                        itemId: 'tab-panel-container',
                        layout: 'fit'
                    }
                ],

                keys: ['PlannedCount', 'CompletedCount', 'Planned PE', 'Completed PE', 'Planned Points',
                    'Completed Points'
                ],

                launch: function () {

                    var that = this;


                    that.rallyFunctions = Ext.create("RallyFunctions", {
                        ctx: that.getContext(),
                        keys: ['peValues', 'iterations', 'projects', 'projectReleases',
                            'piTypes'
                        ]
                    });

                    that.showMask("Loading release data...");
                    that.rallyFunctions.readRallyItems(function (error, bundle) {
                        console.log("rallyFunctions", error, bundle);
                        that.bundle = bundle;
                        that.readReleaseFeatureSnapshots();
                    });
                },

                readReleaseFeatureSnapshots: function () {
                    // read project release feature snapshots
                    // data structure project -> release -> start snapshots, end snapshots
                    var that = this;
                    that.showMask("Loading snapshots...");

                    var prs = _.sortBy(that.bundle.projectReleases, function (pr) {
                        return pr.project.get("Name");
                    })

                    var reqs = [];
                    _.each(prs, function (pr) {
                        _.each(pr.releases, function (lr) {
                            reqs.push({
                                start: true,
                                logicalRelease: lr
                            });
                            reqs.push({
                                start: false,
                                logicalRelease: lr
                            });
                        })
                    })

                    async.map(reqs,
                        that._asyncLoadSnapshotsForReleaseDate.bind(that),
                        function (error, results) {
                            that.hideMask();
                            that._showTable();
                        }
                    )


                },

                showMask: function (msg) {
                    if (this.getEl()) {
                        this.getEl().unmask();
                        this.getEl().mask(msg);
                    }
                },
                hideMask: function () {
                    this.getEl().unmask();
                },


                _showTable: function () {

                    console.log("_showTable");

                    var that = this;
                    var rows = [];

                    var uniqReleases = _.flatten(_.map(that.bundle.projectReleases, function (pr) {
                        return pr.releases;
                    }))
                    uniqReleases = _.uniq(uniqReleases, function (lr) {
                        return lr.name;
                    })
                    that.bundle.uniqReleases = _.sortBy(uniqReleases, function (lr) {
                        return lr.releaseDate;
                    })
                    var rows = [];

                    _.each(that.bundle.projectReleases, function (pr) {
                        _.each(that.keys, function (key) {
                            rows.push(that._makeRow(pr, key));
                        })
                    });

                    that.down("#tab-panel-container").add(that._createTabPanel(rows));

                },

                _createSeries: function (rows, keys) {
                    var that = this;

                    var series = _.map(keys, function (key) {
                        var row = _.find(rows, function (row) {
                            return row.key === key;
                        });

                        return {
                            name: key,
                            data: _.map(that.bundle.uniqReleases, function (ur) {
                                return row[ur.name];
                            })
                        }
                    })

                    return series;
                },

                _createTabPanel: function (rows) {

                    console.log("_createTabPanel");
                    var that = this;

                    that.tabPanel = Ext.create('Ext.tab.Panel', {
                        items: [{
                            title: 'Count',
                            items: that._createTable(rows, ["PlannedCount",
                                "CompletedCount"
                            ])
                        }, {
                            title: 'Estimate',
                            items: that._createTable(rows, ["Planned PE",
                                "Completed PE"
                            ])
                        }, {
                            title: 'Points',
                            items: that._createTable(rows, ["Planned Points",
                                "Completed Points"
                            ])
                        }]
                    });
                    return that.tabPanel;
                },

                _makeRow: function (pr, key) {
                    var that = this;
                    var row = {
                        project: pr.project.get("Name"),
                        key: key
                    };

                    _.each(that.bundle.uniqReleases, function (ur) {
                        var lr = _.find(pr.releases, function (lr) {
                            return lr.name == ur.name
                        });
                        if (_.isNull(lr) || _.isUndefined(lr))
                            row[ur.name] = null;
                        else {
                            row[ur.name] = that._setRowValue(key, lr);
                        }
                    })
                    return row;
                },

                _setRowValue: function (key, lr) {
                    var that = this;
                    var value = 0;

                    var peValue = function (snapshot) {
                        var pev = _.find(that.bundle.preliminaryEstimateValues, function (p) {
                            return p.get("ObjectID") === snapshot.PreliminaryEstimate;
                        });
                        return _.isUndefined(pev) ? 0 : pev.get("Value");
                    };

                    var storyPointValue = function (snapshot) {
                        return (!_.isUndefined(snapshot.LeafStoryPlanEstimateTotal) &&
                                !_.isNull(snapshot.LeafStoryPlanEstimateTotal)) ?
                            snapshot.LeafStoryPlanEstimateTotal : 0;
                    };

                    switch (key) {
                        case "PlannedCount":
                            value = lr.snapshots.start.length == 0 ? null : lr.snapshots.start.length;
                            break;
                        case "CompletedCount":
                            //row[ur.name] = lr.snapshots.end.length == 0 ? null : lr.snapshots.end.length; break;
                            value = lr.snapshots.completed.length == 0 ? null : lr.snapshots.completed
                                .length;
                            break;
                        case "Planned PE":
                            var total = _.reduce(lr.snapshots.start, function (memo, snap) {
                                return memo + peValue(snap);
                            }, 0);
                            value = total == 0 ? null : total;
                            break;
                        case "Completed PE":
                            var total = _.reduce(lr.snapshots.completed, function (memo, snap) {
                                return memo + peValue(snap);
                            }, 0);
                            value = total == 0 ? null : total;
                            break;
                        case "Planned Points":
                            var total = _.reduce(lr.snapshots.start, function (memo, snap) {
                                return memo + storyPointValue(snap);
                            }, 0);
                            value = total == 0 ? null : total;
                            break;
                        case "Completed Points":
                            var total = _.reduce(lr.snapshots.completed, function (memo, snap) {
                                return memo + storyPointValue(snap);
                            }, 0);
                            value = total == 0 ? null : total;
                            break;
                    }
                    return value;
                },

                _createTable: function (rows, keys) {
                    var that = this;

                    var releaseColumns = _.map(that.bundle.uniqReleases, function (ur) {
                        return ur.name;
                    });
                    var fields = [{
                            name: 'project'
                        },
                        {
                            name: 'key'
                        },
                    ];
                    _.each(releaseColumns, function (rc) {
                        fields.push(rc);
                    })

                    var store = new Ext.data.ArrayStore({
                        fields: fields
                    });
                    store.loadData(_.filter(rows, function (row) {
                        return _.contains(keys, row.key)
                    }));

                    var gridColumns = [{
                            header: "Project",
                            sortable: true,
                            dataIndex: 'project'
                        },
                        {
                            header: "Key",
                            sortable: true,
                            dataIndex: 'key'
                        }
                    ];

                    _.each(releaseColumns, function (rc) {
                        gridColumns.push({
                            header: rc,
                            dataIndex: rc
                        });
                    });

                    var grid = new Ext.grid.GridPanel({
                        store: store,
                        columns: gridColumns,
                        stripeRows: true,
                        title: 'Program Release Metrics',
                    });

                    var charts = that._createCharts(_.filter(rows, function (row) {
                        return _.contains(keys, row.key)
                    }), keys, releaseColumns);

                    // return [grid].concat(charts);
                    return charts.concat(grid);
                },

                _transposeJson: function (data, rowKey, cols, rowLabel) {
                    // turns cols into rows
                    var uniqRowKeys = _.uniq(_.map(data, function (d) {
                        return d[rowKey]
                    }));
                    var rows = [];

                    _.each(cols, function (col) {
                        var row = {};
                        row[rowLabel] = col;
                        _.each(uniqRowKeys, function (colKey) {
                            var rowKeyRows = _.filter(data, function (d) {
                                return d[rowKey] === colKey
                            });
                            _.each(rowKeyRows, function (rowKeyRow) {
                                row[colKey] = rowKeyRow[col]
                            })
                        })
                        rows.push(row)
                    })
                    return {
                        rows: rows,
                        rowKeys: uniqRowKeys
                    };
                },

                _calcMaxMin: function (rows, releaseColumns) {

                    // group the rows by project
                    var projectRows = _.groupBy(rows, function (row) {
                        return row.project;
                    });

                    // calc min and max of child projects in order to set the chart scaling properly
                    var childProjects = _.keys(projectRows).slice(1); // list of projects except the first one.
                    console.log("childProjects", childProjects);
                    var cpValues = _.map(childProjects, function (cpName) {
                        var prs = projectRows[cpName];
                        return _.map(prs, function (s) {
                            return _.map(releaseColumns, function (rc) {
                                return s[rc];
                            })
                        })
                    });
                    console.log("cpValues", cpValues);
                    cpValues = _.compact(_.flatten(cpValues));
                    console.log("cpValues", cpValues);
                    console.log("stddev", standardDeviation(cpValues));
                    return {
                        max: _.max(cpValues),
                        min: _.min(cpValues)
                    };
                },


                _createCharts: function (rows, keys, releaseColumns) {

                    var that = this;
                    var ytitle = '';
                    var charts = [];

                    switch (keys[0]) {
                        case 'PlannedCount':
                            ytitle = 'Count';
                            break;
                        case 'Planned PE':
                            ytitle = 'Preliminary Estimate';
                            break;
                        case 'Planned Points':
                            ytitle = 'Points';
                            break;
                    }

                    var maxmin = that._calcMaxMin(rows, releaseColumns);

                    // group the rows by project
                    var projectRows = _.groupBy(rows, function (row) {
                        return row.project;
                    });

                    // calc min and max of child projects in order to set the chart scaling properly
                    var childProjects = _.keys(projectRows).slice(1); // list of projects except the first one.
                    var cpValues = _.map(childProjects, function (cpName) {
                        var pr = projectRows[cpName];
                        return _.map(keys, function (k) {
                            return pr[k];
                        })
                    });
                    console.log("cpValues", cpValues);

                    _.each(_.keys(projectRows), function (project, index) {
                        var prs = projectRows[project];
                        var data = that._transposeJson(prs, "key", releaseColumns,
                            "release");
                        var fields = ['release'].concat(data.rowKeys);
                        var store = Ext.create('Ext.data.JsonStore', {
                            fields: fields,
                            data: data.rows
                        })
                        var chart = Ext.create("Ext.chart.Chart", that._createChartConfig(
                            store, data.rowKeys, 'release', project, ytitle, index,
                            maxmin
                        ));
                        // that.add(chart);
                        // charts.push(chart);
                        // that.add(chart);
                        if (charts.length == 0) { // first chart, add it to a full width container
                            charts.push(
                                Ext.create('Ext.Container', {
                                    "xtype": "container",
                                    "layout": {
                                        "type": "vbox",
                                        "align": "stretch"
                                    },
                                    // "height": "100%",
                                    "items": [chart]
                                }));
                        } else {
                            charts.push(chart);
                        }
                    })
                    return charts;

                },

                _createChartConfig: function (store, fields, labelField, xtitle, ytitle, index, maxmin) {
                    var config = {
                        // renderTo: Ext.getBody(),
                        theme: 'ColumnTheme',
                        width: 300,
                        height: 300,
                        animate: true,
                        store: store,
                        axes: [{
                            type: 'Numeric',
                            position: 'left',
                            fields: fields,
                            label: {
                                renderer: Ext.util.Format.numberRenderer('0,0')
                            },
                            title: ytitle,
                            labelTitle: {
                                font: '11px Arial'
                            },
                            grid: true,
                            // minimum: 0
                        }, {
                            type: 'Category',
                            position: 'bottom',
                            fields: [labelField],
                            title: xtitle
                            // labelTitle: { font: '9px Arial' }

                        }],
                        series: [{
                            type: 'column',
                            axis: 'left',
                            highlight: true,
                            xField: labelField,
                            yField: fields
                        }]
                    }

                    // add a label for the first chart
                    if (index == 0) {
                        console.log("ChartConfig", _.map(fields, function (f) {
                            return " " + f
                        }))
                        config.series[0].label = {
                            display: 'outside',
                            field: fields,
                            renderer: Ext.util.Format.numberRenderer('0'),
                            orientation: 'horizontal',
                            color: '#333'
                        }
                    } else {
                        // set the max / min scaling.
                        config.axes[0].maximum = maxmin.max;
                        config.axes[0].minimum = 0;
                    }
                    return config;

                },

                _getIterationDateForRelease: function (release) {
                    var that = this;
                    // filter iterations to ones ending within release
                    var iterations = _.filter(that.bundle.iterations, function (iteration) {
                        return iteration.get("EndDate") >= release.get("ReleaseStartDate") &&
                            iteration.get("EndDate") <= release.get("ReleaseDate");
                    })
                    iterations = _.sortBy(iterations, function (i) {
                        return i.get("EndDate")
                    });
                    return _.first(iterations);
                },

                uniqSnapshots: function (snapshots) {

                    // returns the last snapshot for each group by ObjectID.

                    var gSnapshots = _.groupBy(snapshots, function (s) {
                        return s["ObjectID"];
                    });

                    var lSnapshots = _.map(_.keys(gSnapshots), function (key) {
                        var s = _.sortBy(gSnapshots[key], function (s) {
                            return s["_ValidFrom"];
                        });
                        return _.last(s);
                    })

                    // console.log(_.map(lSnapshots,function(s){
                    //     return s.FormattedID;
                    // }))
                    return lSnapshots;

                },

                _asyncLoadSnapshotsForReleaseDate: function (req, callback) {

                    var that = this;
                    var dt = null;

                    if (req.start) {
                        var release = _.first(req.logicalRelease.releases);
                        var iteration = that._getIterationDateForRelease(release);
                        if (iteration)
                            dt = iteration.get("EndDate"); // iteration.raw.EndDate;
                        else
                            dt = release.get("ReleaseStartDate"); // release.raw.ReleaseStartDate;

                        dt = Rally.util.DateTime.toIsoString(dt, false);
                    } else {

                        // dt = _.first(req.logicalRelease.releases).raw.ReleaseDate
                        // use the current date to reflect items that may have been colmpleted after
                        // the release ended.
                        dt = new Date().toIsoString();
                    }

                    Ext.create('Rally.data.lookback.SnapshotStore', {
                        autoLoad: true,
                        limit: Infinity,
                        listeners: {
                            refresh: function (store) {
                                var snapshots = [];
                                for (var i = 0, ii = store.getTotalCount(); i < ii; ++i) {
                                    snapshots.push(store.getAt(i).data);
                                }
                                // uniquefy the snapshots.
                                snapshots = that.uniqSnapshots(snapshots);
                                if (_.isUndefined(req.logicalRelease.snapshots))
                                    req.logicalRelease.snapshots = {}
                                if (req.start)
                                    req.logicalRelease.snapshots.start = snapshots
                                else {
                                    req.logicalRelease.snapshots.end = snapshots
                                    // set the completed snapshots
                                    req.logicalRelease.snapshots.completed = _.filter(
                                        snapshots,
                                        function (ss) {
                                            // return ss.PercentDoneByStoryCount == 1;
                                            return !_.isUndefined(ss.ActualEndDate) &&
                                                !_.isNull(ss.ActualEndDate) && ss.ActualEndDate !=
                                                ""
                                        })
                                }
                                callback(null, req)
                            }
                        },
                        fetch: ["Name", "FormattedID", "PreliminaryEstimate", "Release",
                            "LeafStoryPlanEstimateTotal", "PercentDoneByStoryCount",
                            "PercentDoneByStoryPlanEstimate", "LeafStoryCount",
                            "ActualEndDate"
                        ],
                        find: {
                            "_TypeHierarchy": {
                                "$in": [_.first(that.bundle.piTypes).get("TypePath")]
                            },
                            "Release": {
                                "$in": _.map(req.logicalRelease.releases, function (r) {
                                    return r.get("ObjectID");
                                })
                            },
                            "_ValidFrom": {
                                "$lt": dt
                            },
                            "_ValidTo": {
                                "$gt": dt
                            }
                            // "$or" : [
                            //     {"_ValidTo" : {"$gt": dt}},
                            //     {"_ValidTo" : "9999-01-01T00:00:00.000Z"}
                            // ]
                        }
                    });
                    // return deferred.getPromise();
                },

                _loadSnapshotsForReleaseDate: function (start, logicalRelease) {

                    var that = this;
                    var deferred = new Deft.Deferred();
                    var dt = (start) ? _.first(logicalRelease.releases).raw.ReleaseStartDate :
                        _.first(logicalRelease.releases).raw.ReleaseDate

                    if (!start) {
                        if (_.first(logicalRelease.releases).get("ReleaseStartDate") < (new Date())) {
                            if (_.first(logicalRelease.releases).get("ReleaseDate") > (new Date())) {
                                dt = Rally.util.DateTime.toIsoString(new Date(), false);
                            }
                        }
                    }

                    Ext.create('Rally.data.lookback.SnapshotStore', {
                        autoLoad: true,
                        limit: Infinity,
                        listeners: {
                            refresh: function (store) {
                                var snapshots = [];
                                for (var i = 0, ii = store.getTotalCount(); i < ii; ++i) {
                                    snapshots.push(store.getAt(i).data);
                                }
                                if (_.isUndefined(logicalRelease.snapshots))
                                    logicalRelease.snapshots = {}
                                if (start)
                                    logicalRelease.snapshots.start = snapshots
                                else
                                    logicalRelease.snapshots.end = snapshots

                                deferred.resolve(logicalRelease);
                            }
                        },
                        fetch: ["Name", "FormattedID", "PreliminaryEstimate", "Release"],
                        find: {
                            "_TypeHierarchy": {
                                "$in": [_.first(that.bundle.piTypes).get("TypePath")]
                            },
                            "Release": {
                                "$in": _.map(logicalRelease.releases, function (r) {
                                    return r.get("ObjectID");
                                })
                            },
                            "_ValidFrom": {
                                "$lt": dt
                            },
                            "_ValidTo": {
                                "$gt": dt
                            }
                            // "$or" : [
                            //     {"_ValidTo" : {"$gt": dt}},
                            //     {"_ValidTo" : "9999-01-01T00:00:00.000Z"}
                            // ]
                        }
                    });
                    return deferred.getPromise();
                }
            });

            /** this class is configured with { series : [] } where series is a single dimensional array of 
    data values that is filled to full extent of the date range with future values filled with 
    nulls.
**/
            Ext.define("RallyFunctions", function () {

                var self;

                return {
                    config: {
                        ctx: {},
                        filter: null,
                        featureFilter: null,
                        keys: [],
                        fns: {}
                    },

                    constructor: function (config) {
                        self = this;
                        this.initConfig(config);
                        self.fns['scheduleStates'] = self._readStates
                        self.fns['peValues'] = self._loadPreliminaryEstimateValues
                        self.fns['releases'] = self._loadReleases
                        self.fns['iterations'] = self._loadIterations
                        self.fns['projects'] = self._loadProjects
                        self.fns['projectReleases'] = self._loadProjectReleases
                        self.fns['piTypes'] = self._loadPortfolioItemTypes
                        return this;
                    },

                    readRallyItems: function (callback) {

                        var fns = [self._initBundle];
                        _.each(self.keys, function (key) {
                            if (_.contains(_.keys(self.fns), key))
                                fns.push(self.fns[key])
                        });

                        Deft.Chain.pipeline(fns, self).then({
                            success: function (bundle) {
                                callback(null, bundle);
                            },
                            failure: function (error) {
                                //oh noes!
                                console.log("Error:", error);
                                callback(error, null);
                            }
                        });
                    },

                    readProjectWorkItems: function (callback) {

                        console.log('readProjectWorkItems', self.featureFilter);

                        var fns = [
                            self.readStates,
                            self.readProjects,
                            self.readStories
                        ];

                        if (self.featureFilter !== null) {
                            fns = [
                                self.readStates,
                                self.readProjects,
                                self.readFeatures
                            ];
                        }

                        Deft.Chain.pipeline(fns, self).then({
                            success: function (workItems) {
                                callback(null, workItems, self.projects, self.scheduleStates);
                            },
                            failure: function (error) {
                                //oh noes!
                                console.log("Error:", error);
                            }
                        });
                    },

                    _initBundle: function () {
                        console.log("_initBundle");
                        var deferred = Ext.create('Deft.Deferred');
                        deferred.resolve({});
                        return deferred.promise;
                    },

                    _readStates: function (bundle) {
                        var that = this;
                        var deferred = Ext.create('Deft.Deferred');

                        Rally.data.ModelFactory.getModel({
                            type: 'UserStory',
                            success: function (model) {
                                model.getField('ScheduleState').getAllowedValueStore().load({
                                    callback: function (records, operation,
                                        success) {
                                        var scheduleStates = _.map(records,
                                            function (r) {
                                                return r.get(
                                                    "StringValue");
                                            });
                                        deferred.resolve({
                                            scheduleStates: scheduleStates
                                        });
                                    }
                                });
                            }
                        });
                        return deferred.promise;
                    },

                    _loadPreliminaryEstimateValues: function (bundle) {
                        var that = this;
                        console.log("_loadPreliminaryEstimateValues");
                        var deferred = Ext.create('Deft.Deferred');

                        that._loadAStoreWithAPromise(
                            'PreliminaryEstimate',
                            true, []).then({
                            success: function (records) {
                                bundle["preliminaryEstimateValues"] = records;
                                deferred.resolve(bundle);
                            }
                        });
                        return deferred.promise;
                    },

                    _loadReleases: function (bundle) {
                        var that = this;
                        console.log("_loadReleases");
                        var deferred = Ext.create('Deft.Deferred');
                        that._loadAStoreWithAPromise(
                            'Release',
                            true, [], {
                                projectScopeDown: false
                            },
                            "ReleaseDate").then({
                            success: function (records) {
                                bundle["releases"] = records;
                                deferred.resolve(bundle);
                            }
                        });
                        return deferred.promise;
                    },

                    _loadIterations: function (bundle) {
                        var that = this;
                        console.log("_loadIterations");
                        var deferred = Ext.create('Deft.Deferred');
                        that._loadAStoreWithAPromise(
                            'Iteration',
                            true, [], {
                                projectScopeDown: false
                            },
                            "IterationEndDate").then({
                            success: function (records) {
                                bundle["iterations"] = records;
                                deferred.resolve(bundle);
                            }
                        });
                        return deferred.promise;
                    },

                    _loadProjectReleases: function (bundle) {
                        console.log("_loadProjectReleases");
                        var that = this;
                        var deferred = Ext.create('Deft.Deferred');
                        that._loadProjects(bundle).then({
                            success: function (bundle) {
                                // read releases for each project returned.
                                Deft.Promise.map(bundle.projects, function (project) {
                                    // Deft.Chain.sequence( bundle.projects,function(project) {
                                    var deferred = Ext.create('Deft.Deferred');
                                    // model_name, model_fields, filters,ctx,order
                                    self._loadAStoreWithAPromise('Release',
                                        true, [{
                                                property: "ReleaseDate",
                                                operator: ">",
                                                value: self.getLastYearDate()
                                            },
                                            {
                                                property: "ReleaseStartDate",
                                                operator: "<=",
                                                value: self.getToday()
                                            }
                                        ], {
                                            project: project.get("_ref"),
                                            projectScopeDown: true
                                        }
                                    ).then({
                                        success: function (records) {
                                            deferred.resolve(
                                                records);
                                        }
                                    })
                                    return deferred.promise;
                                }).then({
                                    success: function (projectReleases) {
                                        var prs = _.map(bundle.projects,
                                            function (project, i) {
                                                // console.log("context",self.ctx.getProject(),project.get("ObjectID"));
                                                return {
                                                    project: project,
                                                    parent: self.ctx.getProject()
                                                        .ObjectID ==
                                                        project.get(
                                                            "ObjectID"),
                                                    releases: self._groupReleases(
                                                        projectReleases[
                                                            i])
                                                };
                                            });
                                        prs = _.sortBy(prs, function (pr) {
                                            return pr.project.get(
                                                "Name");
                                        })
                                        bundle.projectReleases = _.sortBy(
                                            prs,
                                            function (pr) {
                                                return !(pr.parent);
                                            })
                                        deferred.resolve(bundle);
                                    }
                                })
                            }
                        })
                        return deferred.promise;

                    },

                    _groupReleases: function (releases) {
                        // groups the set of release objects by name, sorts by release date
                        // a logical release is the release name, dates and set of release objects.
                        var groupedReleases = _.groupBy(releases, function (release) {
                            return release.get("Name");
                        });

                        var logicalReleases = _.map(_.keys(groupedReleases), function (key) {
                            var releases = groupedReleases[key];
                            return {
                                name: _.first(releases).get("Name"),
                                releaseDate: _.first(releases).get("ReleaseDate"),
                                releaseStartDate: _.first(releases).get("ReleaseStartDate"),
                                releases: releases
                            }
                        });
                        return _.sortBy(logicalReleases, function (r) {
                            return r.releaseDate;
                        })
                    },

                    _loadProjects: function (bundle) {
                        // reads the set of immediate child projects from the ctx project
                        var that = this;
                        var deferred = Ext.create('Deft.Deferred');
                        var fetch = ["ObjectID", "Name", "_ref", "Parent", "State", "Parent",
                            "Children"
                        ];
                        console.log("_loadProjects");
                        self._loadAStoreWithAPromise('Project',
                            fetch, [{
                                property: "ObjectID",
                                operator: "=",
                                value: self.ctx.getProject().ObjectID
                            }]).then({
                            scope: that,
                            success: function (projects) {
                                if (_.first(projects).get('Children').Count === 0) {
                                    bundle.projects = projects;
                                    deferred.resolve(bundle);
                                } else {
                                    _.first(projects).getCollection('Children').load({
                                        fetch: fetch,
                                        callback: function (records, operation,
                                            success) {
                                            bundle.projects = _.filter(
                                                records,
                                                function (r) {
                                                    return r.get(
                                                            "State") !==
                                                        "Closed";
                                                });
                                            bundle.projects.unshift(_.first(
                                                projects));
                                            deferred.resolve(bundle);
                                        }
                                    });
                                }
                            }
                        });
                        return deferred.promise;
                    },

                    _loadPortfolioItemTypes: function (bundle) {
                        console.log("_loadPortfolioItemTypes");
                        var deferred = Ext.create('Deft.Deferred');

                        self._loadAStoreWithAPromise(
                            'TypeDefinition',
                            true, [{
                                property: "Ordinal",
                                operator: "!=",
                                value: -1
                            }]).then({
                            success: function (records) {
                                bundle["piTypes"] = records;
                                deferred.resolve(bundle);
                            }
                        })

                        return deferred.promise;
                    },

                    readProjects: function (states) {

                        var deferred = Ext.create('Deft.Deferred');
                        var me = this;

                        self._loadAStoreWithAPromise('Project', ["_ref", "Parent", "Children"], [{
                            property: "ObjectID",
                            operator: "=",
                            value: self.ctx.getProject().ObjectID
                        }]).then({
                            scope: me,
                            success: function (projects) {
                                if (_.first(projects).get('Children').Count === 0) {
                                    self.projects = projects;
                                    deferred.resolve(self.projects);
                                } else {
                                    _.first(projects).getCollection('Children').load({
                                        fetch: ["ObjectID", "Name", "_ref",
                                            "Parent", "State"
                                        ],
                                        callback: function (records, operation,
                                            success) {
                                            self.projects = _.filter(
                                                records,
                                                function (r) {
                                                    return r.get(
                                                            "State") !==
                                                        "Closed";
                                                });
                                            self.projects.push(_.first(
                                                projects));
                                            console.log("self.projects",
                                                self.projects, projects
                                            );
                                            deferred.resolve(self.projects);
                                        }
                                    });
                                }
                            }
                        });
                        return deferred.promise;
                    },

                    readStories: function (projects) {
                        console.log('readStories', projects, self.filter);
                        var me = this;

                        var promises = _.map(projects, function (project) {
                            var deferred = Ext.create('Deft.Deferred');
                            self._loadAStoreWithAPromise(
                                'HierarchicalRequirement', ["ObjectID", "ScheduleState",
                                    "PlanEstimate", "Project"
                                ], [self.filter], {
                                    project: project.get("_ref"),
                                    projectScopeUp: false,
                                    projectScopeDown: true
                                }).then({
                                scope: me,
                                success: function (stories) {
                                    console.log('stories', stories);
                                    deferred.resolve(stories);
                                }
                            });
                            return deferred.promise;
                        });

                        return Deft.Promise.all(promises);

                    },

                    readFeatures: function (projects) {

                        var me = this;

                        var readFeatureType = function () {
                            var deferred = Ext.create('Deft.Deferred');
                            self._loadAStoreWithAPromise(
                                'TypeDefinition', ["TypePath"], [{
                                    property: "Ordinal",
                                    operator: "=",
                                    value: 0
                                }]
                            ).then({
                                scope: me,
                                success: function (types) {
                                    deferred.resolve(_.first(types).get("TypePath"));
                                }
                            });
                            return deferred.promise;
                        };

                        var readFeatures = function (type) {

                            var promises = _.map(projects, function (project) {
                                var deferred = Ext.create('Deft.Deferred');
                                self._loadAStoreWithAPromise(
                                    type, ["FormattedID", "Name", "ObjectID",
                                        "LeafStoryCount",
                                        "LeafStoryPlanEstimateTotal",
                                        "PreliminaryEstimate",
                                        "AcceptedLeafStoryCount",
                                        "AcceptedLeafStoryPlanEstimateTotal",
                                        "PercentDoneByStoryCount",
                                        "c_ValueMetricKPI", "Rank", "State"
                                    ], [self.featureFilter], {
                                        project: project.get("_ref"),
                                        projectScopeUp: false,
                                        projectScopeDown: true
                                    }, [{
                                        property: 'DragAndDropRank',
                                        direction: 'ASC'
                                    }]).then({
                                    scope: me,
                                    success: function (stories) {
                                        deferred.resolve(stories);
                                    }
                                });
                                return deferred.promise;
                            });

                            return Deft.Promise.all(promises);
                        };

                        var deferred = Ext.create('Deft.Deferred');
                        Deft.Chain.pipeline([readFeatureType, readFeatures], self).then({
                            success: function (results) {
                                deferred.resolve(results);
                            }
                        });
                        return deferred.promise;

                    },

                    readPreferenceValues: function (keys) {

                        var me = this;

                        var promises = _.map(keys, function (key) {
                            var deferred = Ext.create('Deft.Deferred');
                            self._loadAStoreWithAPromise(
                                "Preference", ["Name", "Value"], [{
                                    property: "Name",
                                    operator: "=",
                                    value: key
                                }]
                            ).then({
                                scope: me,
                                success: function (values) {
                                    deferred.resolve(values);
                                },
                                failure: function (error) {
                                    deferred.resolve("");
                                }
                            });
                            return deferred.promise;
                        });
                        return Deft.Promise.all(promises);
                    },

                    _loadAStoreWithAPromise: function (model_name, model_fields, filters, ctx, order) {
                        var deferred = Ext.create('Deft.Deferred');
                        var me = this;

                        var config = {
                            model: model_name,
                            fetch: model_fields,
                            filters: filters,
                            limit: 'Infinity'
                        };
                        if (!_.isUndefined(ctx) && !_.isNull(ctx)) {
                            config.context = ctx;
                        }
                        if (!_.isUndefined(order) && !_.isNull(order)) {
                            config.order = order;
                        }

                        Ext.create('Rally.data.wsapi.Store', config).load({
                            callback: function (records, operation, successful) {
                                if (successful) {
                                    deferred.resolve(records);
                                } else {
                                    deferred.reject('Problem loading: ' + operation.error
                                        .errors.join('. '));
                                }
                            }
                        });
                        return deferred.promise;
                    },

                    getLastYearDate: function () {
                        var date = new Date();
                        date.setFullYear(date.getFullYear() - 1);
                        return Rally.util.DateTime.toIsoString(date, false);
                    },
                    getToday: function () {
                        var date = new Date();
                        return Rally.util.DateTime.toIsoString(date, false);
                    },

                    recurseObject: function (obj, callback) {

                        var deferred = Ext.create('Deft.Deferred');
                        var list = [];
                        var stack = 1;

                        var childItems = function (obj, collection, callback) {
                            var children = obj.get(collection);

                            if (children && children.Count > 0) {
                                stack = stack + children.Count;
                                obj.getCollection(collection).load({
                                    fetch: true,
                                    callback: function (records, operation, success) {
                                        callback(records);
                                    }
                                });
                            }
                        };

                        var walk = function (root) {
                            console.log(root.get("FormattedID"), stack);
                            list.push(root);
                            stack = stack - 1;

                            _.each(["Children", "UserStories", "Tasks", "Defects", "TestCases"],
                                function (collection) {
                                    childItems(root, collection, function (records) {
                                        _.each(records, function (record) {
                                            walk(record);
                                        })
                                    });
                                })
                            console.log(root.get("FormattedID"), stack);
                            if (stack == 0) {
                                deferred.resolve(list);
                            }
                        }

                        walk(obj);

                        return deferred.promise;
                    }

                };
            });
            Ext.define('Rally.technicalservices.programVelocityChart', function () {

                var self;

                return {
                    extend: 'Rally.ui.chart.Chart',
                    alias: 'widget.progresschart',

                    // itemId: 'rally-chart',
                    chartData: {

                    },
                    loadMask: false,
                    // chartColors : ["#CCCCCC","#00a9e0","#009933","#CCCCCC","#00a9e0","#009933"],
                    chartConfig: {
                        chart: {
                            type: 'column',
                            zoomType: 'xy'
                        },
                        title: {
                            text: 'Program Velocity Metrics'
                        },
                        subtitle: {
                            text: ''
                        },
                        xAxis: {
                            title: {
                                enabled: true,
                                text: 'Day'
                            },
                            startOnTick: true,
                            endOnTick: true,
                            min: 0
                        },
                        yAxis: [{
                            title: {
                                text: 'Value'
                            },
                            plotLines: [{
                                color: '#000000',
                                width: 1,
                                value: 0,
                                zIndex: 4,
                                label: {
                                    text: "-"
                                }
                            }]
                        }],

                        plotOptions: {
                            series: {
                                point: {
                                    events: {
                                        click: function (a) {}
                                    }
                                },
                                pointPadding: 0.1,
                                groupPadding: 0,
                                borderWidth: 0
                            },
                            column: {
                                stacking: 'normal',
                            },
                        }
                    },

                    initComponent: function () {
                        this.callParent(arguments);
                        this.addEvents('series_click');
                    },

                    constructor: function (config) {
                        self = this;
                        self.callParent(arguments);
                        this.initConfig(config);

                        if (config.title) {
                            self.chartConfig.title.text = config.title;
                        }
                        self.itemId = config.itemId



                        self.chartData = config.chartData;

                        return self;
                    }
                }
            });
            ! function (n, t) {
                "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define &&
                    define.amd ? define(["exports"], t) : t(n.async = n.async || {})
            }(this, function (n) {
                "use strict";

                function t(n, t, e) {
                    switch (e.length) {
                        case 0:
                            return n.call(t);
                        case 1:
                            return n.call(t, e[0]);
                        case 2:
                            return n.call(t, e[0], e[1]);
                        case 3:
                            return n.call(t, e[0], e[1], e[2])
                    }
                    return n.apply(t, e)
                }

                function e(n, e) {
                    return e = et(void 0 === e ? n.length - 1 : e, 0),
                        function () {
                            for (var r = arguments, u = -1, i = et(r.length - e, 0), o = Array(i); ++u < i;)
                                o[u] = r[e + u];
                            u = -1;
                            for (var c = Array(e + 1); ++u < e;) c[u] = r[u];
                            return c[e] = o, t(n, this, c)
                        }
                }

                function r(n) {
                    return e(function (t) {
                        var e = t.pop();
                        n.call(this, t, e)
                    })
                }

                function u(n) {
                    return e(function (t, e) {
                        var u = r(function (e, r) {
                            var u = this;
                            return n(t, function (n, t) {
                                n.apply(u, e.concat([t]))
                            }, r)
                        });
                        return e.length ? u.apply(this, e) : u
                    })
                }

                function i(n) {
                    return function (t) {
                        return null == t ? void 0 : t[n]
                    }
                }

                function o(n) {
                    var t = typeof n;
                    return !!n && ("object" == t || "function" == t)
                }

                function c(n) {
                    var t = o(n) ? ct.call(n) : "";
                    return t == ut || t == it
                }

                function f(n) {
                    return "number" == typeof n && n > -1 && n % 1 == 0 && ft >= n
                }

                function a(n) {
                    return null != n && f(rt(n)) && !c(n)
                }

                function l() {}

                function s(n) {
                    return function () {
                        if (null !== n) {
                            var t = n;
                            n = null, t.apply(this, arguments)
                        }
                    }
                }

                function p(n) {
                    return at && n[at] && n[at]()
                }

                function h(n, t) {
                    return function (e) {
                        return n(t(e))
                    }
                }

                function y(n, t) {
                    return null != n && (ht.call(n, t) || "object" == typeof n && t in n && null === st(n))
                }

                function v(n, t) {
                    for (var e = -1, r = Array(n); ++e < n;) r[e] = t(e);
                    return r
                }

                function m(n) {
                    return !!n && "object" == typeof n
                }

                function d(n) {
                    return m(n) && a(n)
                }

                function g(n) {
                    return d(n) && gt.call(n, "callee") && (!St.call(n, "callee") || bt.call(n) == mt)
                }

                function b(n) {
                    return "string" == typeof n || !jt(n) && m(n) && Lt.call(n) == kt
                }

                function S(n) {
                    var t = n ? n.length : void 0;
                    return f(t) && (jt(n) || b(n) || g(n)) ? v(t, String) : null
                }

                function j(n, t) {
                    return t = null == t ? Et : t, !!t && ("number" == typeof n || Ot.test(n)) && n > -1 &&
                        n % 1 == 0 && t > n
                }

                function k(n) {
                    var t = n && n.constructor,
                        e = "function" == typeof t && t.prototype || xt;
                    return n === e
                }

                function w(n) {
                    var t = k(n);
                    if (!t && !a(n)) return vt(n);
                    var e = S(n),
                        r = !!e,
                        u = e || [],
                        i = u.length;
                    for (var o in n) !y(n, o) || r && ("length" == o || j(o, i)) || t && "constructor" == o ||
                        u.push(o);
                    return u
                }

                function L(n) {
                    var t = -1,
                        e = n.length;
                    return function () {
                        return ++t < e ? {
                            value: n[t],
                            key: t
                        } : null
                    }
                }

                function E(n) {
                    var t = -1;
                    return function () {
                        var e = n.next();
                        return e.done ? null : (t++, {
                            value: e.value,
                            key: t
                        })
                    }
                }

                function O(n) {
                    var t = w(n),
                        e = -1,
                        r = t.length;
                    return function () {
                        var u = t[++e];
                        return r > e ? {
                            value: n[u],
                            key: u
                        } : null
                    }
                }

                function x(n) {
                    if (a(n)) return L(n);
                    var t = p(n);
                    return t ? E(t) : O(n)
                }

                function A(n) {
                    return function () {
                        if (null === n) throw new Error("Callback was already called.");
                        var t = n;
                        n = null, t.apply(this, arguments)
                    }
                }

                function _(n) {
                    return function (t, e, r) {
                        function u(n) {
                            if (f -= 1, n) c = !0, r(n);
                            else {
                                if (c && 0 >= f) return r(null);
                                i()
                            }
                        }

                        function i() {
                            for (; n > f && !c;) {
                                var t = o();
                                if (null === t) return c = !0, void(0 >= f && r(null));
                                f += 1, e(t.value, t.key, A(u))
                            }
                        }
                        if (r = s(r || l), 0 >= n || !t) return r(null);
                        var o = x(t),
                            c = !1,
                            f = 0;
                        i()
                    }
                }

                function I(n, t, e, r) {
                    _(t)(n, e, r)
                }

                function T(n, t) {
                    return function (e, r, u) {
                        return n(e, t, r, u)
                    }
                }

                function F(n, t, e) {
                    function r(n) {
                        n ? e(n) : ++i === o && e(null)
                    }
                    e = s(e || l);
                    var u = 0,
                        i = 0,
                        o = n.length;
                    for (0 === o && e(null); o > u; u++) t(n[u], u, A(r))
                }

                function z(n, t, e) {
                    var r = a(n) ? F : At;
                    r(n, t, e)
                }

                function B(n) {
                    return function (t, e, r) {
                        return n(z, t, e, r)
                    }
                }

                function M(n, t, e, r) {
                    r = s(r || l), t = t || [];
                    var u = [],
                        i = 0;
                    n(t, function (n, t, r) {
                        var o = i++;
                        e(n, function (n, t) {
                            u[o] = t, r(n)
                        })
                    }, function (n) {
                        r(n, u)
                    })
                }

                function V(n) {
                    return function (t, e, r, u) {
                        return n(_(e), t, r, u)
                    }
                }

                function q(n) {
                    return r(function (t, e) {
                        var r;
                        try {
                            r = n.apply(this, t)
                        } catch (u) {
                            return e(u)
                        }
                        o(r) && "function" == typeof r.then ? r.then(function (n) {
                            e(null, n)
                        }, function (n) {
                            e(n.message ? n : new Error(n))
                        }) : e(null, r)
                    })
                }

                function $(n, t) {
                    for (var e = -1, r = n ? n.length : 0; ++e < r && t(n[e], e, n) !== !1;);
                    return n
                }

                function C(n) {
                    return function (t, e, r) {
                        for (var u = -1, i = Object(t), o = r(t), c = o.length; c--;) {
                            var f = o[n ? c : ++u];
                            if (e(i[f], f, i) === !1) break
                        }
                        return t
                    }
                }

                function D(n, t) {
                    return n && Mt(n, t, w)
                }

                function P(n, t, e, r) {
                    for (var u = n.length, i = e + (r ? 1 : -1); r ? i-- : ++i < u;)
                        if (t(n[i], i, n)) return i;
                    return -1
                }

                function R(n) {
                    return n !== n
                }

                function U(n, t, e) {
                    if (t !== t) return P(n, R, e);
                    for (var r = e - 1, u = n.length; ++r < u;)
                        if (n[r] === t) return r;
                    return -1
                }

                function Q(n, t, r) {
                    function u(n, t) {
                        b.push(function () {
                            f(n, t)
                        })
                    }

                    function i() {
                        if (0 === b.length && 0 === m) return r(null, v);
                        for (; b.length && t > m;) {
                            var n = b.shift();
                            n()
                        }
                    }

                    function o(n, t) {
                        var e = g[n];
                        e || (e = g[n] = []), e.push(t)
                    }

                    function c(n) {
                        var t = g[n] || [];
                        $(t, function (n) {
                            n()
                        }), i()
                    }

                    function f(n, t) {
                        if (!d) {
                            var u = A(e(function (t, e) {
                                if (m--, e.length <= 1 && (e = e[0]), t) {
                                    var u = {};
                                    D(v, function (n, t) {
                                        u[t] = n
                                    }), u[n] = e, d = !0, g = [], r(t, u)
                                } else v[n] = e, c(n)
                            }));
                            m++;
                            var i = t[t.length - 1];
                            t.length > 1 ? i(v, u) : i(u)
                        }
                    }

                    function a() {
                        for (var n, t = 0; S.length;) n = S.pop(), t++, $(p(n), function (n) {
                            0 === --j[n] && S.push(n)
                        });
                        if (t !== y) throw new Error(
                            "async.auto cannot execute tasks due to a recursive dependency")
                    }

                    function p(t) {
                        var e = [];
                        return D(n, function (n, r) {
                            jt(n) && U(n, t, 0) >= 0 && e.push(r)
                        }), e
                    }
                    "function" == typeof t && (r = t, t = null), r = s(r || l);
                    var h = w(n),
                        y = h.length;
                    if (!y) return r(null);
                    t || (t = y);
                    var v = {},
                        m = 0,
                        d = !1,
                        g = {},
                        b = [],
                        S = [],
                        j = {};
                    D(n, function (t, e) {
                        if (!jt(t)) return u(e, [t]), void S.push(e);
                        var r = t.slice(0, t.length - 1),
                            i = r.length;
                        return 0 === i ? (u(e, t), void S.push(e)) : (j[e] = i, void $(r, function (
                            c) {
                            if (!n[c]) throw new Error("async.auto task `" + e +
                                "` has a non-existent dependency in " + r.join(
                                    ", "));
                            o(c, function () {
                                i--, 0 === i && u(e, t)
                            })
                        }))
                    }), a(), i()
                }

                function W(n, t) {
                    for (var e = -1, r = n ? n.length : 0, u = Array(r); ++e < r;) u[e] = t(n[e], e, n);
                    return u
                }

                function G(n, t) {
                    var e = -1,
                        r = n.length;
                    for (t || (t = Array(r)); ++e < r;) t[e] = n[e];
                    return t
                }

                function H(n) {
                    return "symbol" == typeof n || m(n) && Rt.call(n) == Dt
                }

                function J(n) {
                    if ("string" == typeof n) return n;
                    if (H(n)) return Wt ? Wt.call(n) : "";
                    var t = n + "";
                    return "0" == t && 1 / n == -Ut ? "-0" : t
                }

                function K(n, t, e) {
                    var r = -1,
                        u = n.length;
                    0 > t && (t = -t > u ? 0 : u + t), e = e > u ? u : e, 0 > e && (e += u), u = t > e ? 0 :
                        e - t >>> 0, t >>>= 0;
                    for (var i = Array(u); ++r < u;) i[r] = n[r + t];
                    return i
                }

                function N(n, t, e) {
                    var r = n.length;
                    return e = void 0 === e ? r : e, !t && e >= r ? n : K(n, t, e)
                }

                function X(n, t) {
                    for (var e = n.length; e-- && U(t, n[e], 0) > -1;);
                    return e
                }

                function Y(n, t) {
                    for (var e = -1, r = n.length; ++e < r && U(t, n[e], 0) > -1;);
                    return e
                }

                function Z(n) {
                    return n.match(ae)
                }

                function nn(n) {
                    return null == n ? "" : J(n)
                }

                function tn(n, t, e) {
                    if (n = nn(n), n && (e || void 0 === t)) return n.replace(le, "");
                    if (!n || !(t = J(t))) return n;
                    var r = Z(n),
                        u = Z(t),
                        i = Y(r, u),
                        o = X(r, u) + 1;
                    return N(r, i, o).join("")
                }

                function en(n) {
                    return n = n.toString().replace(ye, ""), n = n.match(se)[2].replace(" ", ""), n = n ? n
                        .split(pe) : [], n = n.map(function (n) {
                            return tn(n.replace(he, ""))
                        })
                }

                function rn(n, t) {
                    var e = {};
                    D(n, function (n, t) {
                        function r(t, e) {
                            var r = W(u, function (n) {
                                return t[n]
                            });
                            r.push(e), n.apply(null, r)
                        }
                        var u;
                        if (jt(n)) u = G(n), n = u.pop(), e[t] = u.concat(u.length > 0 ? r : n);
                        else if (1 === n.length) e[t] = n;
                        else {
                            if (u = en(n), 0 === n.length && 0 === u.length) throw new Error(
                                "autoInject task functions require explicit parameters.");
                            u.pop(), e[t] = u.concat(r)
                        }
                    }), Q(e, t)
                }

                function un(n) {
                    setTimeout(n, 0)
                }

                function on(n) {
                    return e(function (t, e) {
                        n(function () {
                            t.apply(null, e)
                        })
                    })
                }

                function cn() {
                    this.head = this.tail = null, this.length = 0
                }

                function fn(n, t) {
                    n.length = 1, n.head = n.tail = t
                }

                function an(n, t, r) {
                    function u(n, t, e) {
                        if (null != e && "function" != typeof e) throw new Error(
                            "task callback must be a function");
                        return f.started = !0, jt(n) || (n = [n]), 0 === n.length && f.idle() ? de(function () {
                            f.drain()
                        }) : ($(n, function (n) {
                            var r = {
                                data: n,
                                callback: e || l
                            };
                            t ? f._tasks.unshift(r) : f._tasks.push(r)
                        }), void de(f.process))
                    }

                    function i(n) {
                        return e(function (t) {
                            o -= 1, $(n, function (n) {
                                    $(c, function (t, e) {
                                        return t === n ? (c.splice(e, 1), !1) : void 0
                                    }), n.callback.apply(n, t), null != t[0] && f.error(t[0],
                                        n.data)
                                }), o <= f.concurrency - f.buffer && f.unsaturated(), f.idle() && f
                                .drain(), f.process()
                        })
                    }
                    if (null == t) t = 1;
                    else if (0 === t) throw new Error("Concurrency must not be zero");
                    var o = 0,
                        c = [],
                        f = {
                            _tasks: new cn,
                            concurrency: t,
                            payload: r,
                            saturated: l,
                            unsaturated: l,
                            buffer: t / 4,
                            empty: l,
                            drain: l,
                            error: l,
                            started: !1,
                            paused: !1,
                            push: function (n, t) {
                                u(n, !1, t)
                            },
                            kill: function () {
                                f.drain = l, f._tasks.empty()
                            },
                            unshift: function (n, t) {
                                u(n, !0, t)
                            },
                            process: function () {
                                for (; !f.paused && o < f.concurrency && f._tasks.length;) {
                                    var t = [],
                                        e = [],
                                        r = f._tasks.length;
                                    f.payload && (r = Math.min(r, f.payload));
                                    for (var u = 0; r > u; u++) {
                                        var a = f._tasks.shift();
                                        t.push(a), e.push(a.data)
                                    }
                                    0 === f._tasks.length && f.empty(), o += 1, c.push(t[0]), o === f.concurrency &&
                                        f.saturated();
                                    var l = A(i(t));
                                    n(e, l)
                                }
                            },
                            length: function () {
                                return f._tasks.length
                            },
                            running: function () {
                                return o
                            },
                            workersList: function () {
                                return c
                            },
                            idle: function () {
                                return f._tasks.length + o === 0
                            },
                            pause: function () {
                                f.paused = !0
                            },
                            resume: function () {
                                if (f.paused !== !1) {
                                    f.paused = !1;
                                    for (var n = Math.min(f.concurrency, f._tasks.length), t = 1; n >=
                                        t; t++) de(f.process)
                                }
                            }
                        };
                    return f
                }

                function ln(n, t) {
                    return an(n, 1, t)
                }

                function sn(n, t, e, r) {
                    r = s(r || l), be(n, function (n, r, u) {
                        e(t, n, function (n, e) {
                            t = e, u(n)
                        })
                    }, function (n) {
                        r(n, t)
                    })
                }

                function pn(n, t, e, r) {
                    var u = [];
                    n(t, function (n, t, r) {
                        e(n, function (n, t) {
                            u = u.concat(t || []), r(n)
                        })
                    }, function (n) {
                        r(n, u)
                    })
                }

                function hn(n) {
                    return function (t, e, r) {
                        return n(be, t, e, r)
                    }
                }

                function yn(n) {
                    return n
                }

                function vn(n, t, e) {
                    return function (r, u, i, o) {
                        function c(n) {
                            o && (n ? o(n) : o(null, e(!1)))
                        }

                        function f(n, r, u) {
                            return o ? void i(n, function (r, c) {
                                o && (r ? (o(r), o = i = !1) : t(c) && (o(null, e(!0, n)), o =
                                    i = !1)), u()
                            }) : u()
                        }
                        arguments.length > 3 ? (o = o || l, n(r, u, f, c)) : (o = i, o = o || l, i = u,
                            n(r, f, c))
                    }
                }

                function mn(n, t) {
                    return t
                }

                function dn(n) {
                    return e(function (t, r) {
                        t.apply(null, r.concat([e(function (t, e) {
                            "object" == typeof console && (t ? console.error &&
                                console.error(t) : console[n] && $(e,
                                    function (t) {
                                        console[n](t)
                                    }))
                        })]))
                    })
                }

                function gn(n, t, r) {
                    function u(t, e) {
                        return t ? r(t) : e ? void n(i) : r(null)
                    }
                    r = A(r || l);
                    var i = e(function (n, e) {
                        return n ? r(n) : (e.push(u), void t.apply(this, e))
                    });
                    u(null, !0)
                }

                function bn(n, t, r) {
                    r = A(r || l);
                    var u = e(function (e, i) {
                        return e ? r(e) : t.apply(this, i) ? n(u) : void r.apply(null, [null].concat(
                            i))
                    });
                    n(u)
                }

                function Sn(n, t, e) {
                    bn(n, function () {
                        return !t.apply(this, arguments)
                    }, e)
                }

                function jn(n, t, e) {
                    function r(t) {
                        return t ? e(t) : void n(u)
                    }

                    function u(n, u) {
                        return n ? e(n) : u ? void t(r) : e(null)
                    }
                    e = A(e || l), n(u)
                }

                function kn(n) {
                    return function (t, e, r) {
                        return n(t, r)
                    }
                }

                function wn(n, t, e) {
                    z(n, kn(t), e)
                }

                function Ln(n, t, e, r) {
                    _(t)(n, kn(e), r)
                }

                function En(n) {
                    return r(function (t, e) {
                        var r = !0;
                        t.push(function () {
                            var n = arguments;
                            r ? de(function () {
                                e.apply(null, n)
                            }) : e.apply(null, n)
                        }), n.apply(this, t), r = !1
                    })
                }

                function On(n) {
                    return !n
                }

                function xn(n, t, e, r) {
                    r = s(r || l);
                    var u = [];
                    n(t, function (n, t, r) {
                        e(n, function (e, i) {
                            e ? r(e) : (i && u.push({
                                index: t,
                                value: n
                            }), r())
                        })
                    }, function (n) {
                        n ? r(n) : r(null, W(u.sort(function (n, t) {
                            return n.index - t.index
                        }), i("value")))
                    })
                }

                function An(n, t) {
                    function e(n) {
                        return n ? r(n) : void u(e)
                    }
                    var r = A(t || l),
                        u = En(n);
                    e()
                }

                function _n(n, t, e, r) {
                    r = s(r || l);
                    var u = {};
                    I(n, t, function (n, t, r) {
                        e(n, t, function (n, e) {
                            return n ? r(n) : (u[t] = e, void r())
                        })
                    }, function (n) {
                        r(n, u)
                    })
                }

                function In(n, t) {
                    return t in n
                }

                function Tn(n, t) {
                    var u = Object.create(null),
                        i = Object.create(null);
                    t = t || yn;
                    var o = r(function (r, o) {
                        var c = t.apply(null, r);
                        In(u, c) ? de(function () {
                            o.apply(null, u[c])
                        }) : In(i, c) ? i[c].push(o) : (i[c] = [o], n.apply(null, r.concat([e(
                            function (n) {
                                u[c] = n;
                                var t = i[c];
                                delete i[c];
                                for (var e = 0, r = t.length; r > e; e++) t[e].apply(
                                    null, n)
                            })])))
                    });
                    return o.memo = u, o.unmemoized = n, o
                }

                function Fn(n, t, r) {
                    r = r || l;
                    var u = a(t) ? [] : {};
                    n(t, function (n, t, r) {
                        n(e(function (n, e) {
                            e.length <= 1 && (e = e[0]), u[t] = e, r(n)
                        }))
                    }, function (n) {
                        r(n, u)
                    })
                }

                function zn(n, t) {
                    Fn(z, n, t)
                }

                function Bn(n, t, e) {
                    Fn(_(t), n, e)
                }

                function Mn(n, t) {
                    return an(function (t, e) {
                        n(t[0], e)
                    }, t, 1)
                }

                function Vn(n, t) {
                    var e = Mn(n, t);
                    return e.push = function (n, t, r) {
                        if (null == r && (r = l), "function" != typeof r) throw new Error(
                            "task callback must be a function");
                        if (e.started = !0, jt(n) || (n = [n]), 0 === n.length) return de(function () {
                            e.drain()
                        });
                        t = t || 0;
                        for (var u = e._tasks.head; u && t >= u.priority;) u = u.next;
                        $(n, function (n) {
                            var i = {
                                data: n,
                                priority: t,
                                callback: r
                            };
                            u ? e._tasks.insertBefore(u, i) : e._tasks.push(i)
                        }), de(e.process)
                    }, delete e.unshift, e
                }

                function qn(n, t) {
                    return t = s(t || l), jt(n) ? n.length ? void $(n, function (n) {
                        n(t)
                    }) : t() : t(new TypeError("First argument to race must be an array of functions"))
                }

                function $n(n, t, e, r) {
                    var u = De.call(n).reverse();
                    sn(u, t, e, r)
                }

                function Cn(n) {
                    return r(function (t, r) {
                        return t.push(e(function (n, t) {
                            if (n) r(null, {
                                error: n
                            });
                            else {
                                var e = null;
                                1 === t.length ? e = t[0] : t.length > 1 && (e = t), r(
                                    null, {
                                        value: e
                                    })
                            }
                        })), n.apply(this, t)
                    })
                }

                function Dn(n, t, e, r) {
                    xn(n, t, function (n, t) {
                        e(n, function (n, e) {
                            n ? t(n) : t(null, !e)
                        })
                    }, r)
                }

                function Pn(n) {
                    var t;
                    return jt(n) ? t = W(n, Cn) : (t = {}, D(n, function (n, e) {
                        t[e] = Cn.call(this, n)
                    })), t
                }

                function Rn(n) {
                    return function () {
                        return n
                    }
                }

                function Un(n, t, e) {
                    function r(n, t) {
                        if ("object" == typeof t) n.times = +t.times || i, n.intervalFunc = "function" ==
                            typeof t.interval ? t.interval : Rn(+t.interval || o);
                        else {
                            if ("number" != typeof t && "string" != typeof t) throw new Error(
                                "Invalid arguments for async.retry");
                            n.times = +t || i
                        }
                    }

                    function u() {
                        t(function (n) {
                            n && f++ < c.times ? setTimeout(u, c.intervalFunc(f)) : e.apply(null,
                                arguments)
                        })
                    }
                    var i = 5,
                        o = 0,
                        c = {
                            times: i,
                            intervalFunc: Rn(o)
                        };
                    if (arguments.length < 3 && "function" == typeof n ? (e = t || l, t = n) : (r(c, n), e =
                            e || l), "function" != typeof t) throw new Error(
                        "Invalid arguments for async.retry");
                    var f = 1;
                    u()
                }

                function Qn(n, t) {
                    return t || (t = n, n = null), r(function (e, r) {
                        function u(n) {
                            t.apply(null, e.concat([n]))
                        }
                        n ? Un(n, u, r) : Un(u, r)
                    })
                }

                function Wn(n, t) {
                    Fn(be, n, t)
                }

                function Gn(n, t, e) {
                    function r(n, t) {
                        var e = n.criteria,
                            r = t.criteria;
                        return r > e ? -1 : e > r ? 1 : 0
                    }
                    _t(n, function (n, e) {
                        t(n, function (t, r) {
                            return t ? e(t) : void e(null, {
                                value: n,
                                criteria: r
                            })
                        })
                    }, function (n, t) {
                        return n ? e(n) : void e(null, W(t.sort(r), i("value")))
                    })
                }

                function Hn(n, t, e) {
                    function u() {
                        f || (o.apply(null, arguments), clearTimeout(c))
                    }

                    function i() {
                        var t = n.name || "anonymous",
                            r = new Error('Callback function "' + t + '" timed out.');
                        r.code = "ETIMEDOUT", e && (r.info = e), f = !0, o(r)
                    }
                    var o, c, f = !1;
                    return r(function (e, r) {
                        o = r, c = setTimeout(i, t), n.apply(null, e.concat(u))
                    })
                }

                function Jn(n, t, e, r) {
                    for (var u = -1, i = Je(He((t - n) / (e || 1)), 0), o = Array(i); i--;) o[r ? i : ++u] =
                        n, n += e;
                    return o
                }

                function Kn(n, t, e, r) {
                    Tt(Jn(0, n, 1), t, e, r)
                }

                function Nn(n, t, e, r) {
                    3 === arguments.length && (r = e, e = t, t = jt(n) ? [] : {}), r = s(r || l), z(n,
                        function (n, r, u) {
                            e(t, n, r, u)
                        },
                        function (n) {
                            r(n, t)
                        })
                }

                function Xn(n) {
                    return function () {
                        return (n.unmemoized || n).apply(null, arguments)
                    }
                }

                function Yn(n, t, r) {
                    if (r = A(r || l), !n()) return r(null);
                    var u = e(function (e, i) {
                        return e ? r(e) : n() ? t(u) : void r.apply(null, [null].concat(i))
                    });
                    t(u)
                }

                function Zn(n, t, e) {
                    Yn(function () {
                        return !n.apply(this, arguments)
                    }, t, e)
                }

                function nt(n, t) {
                    function r(i) {
                        if (u === n.length) return t.apply(null, [null].concat(i));
                        var o = A(e(function (n, e) {
                            return n ? t.apply(null, [n].concat(e)) : void r(e)
                        }));
                        i.push(o);
                        var c = n[u++];
                        c.apply(null, i)
                    }
                    if (t = s(t || l), !jt(n)) return t(new Error(
                        "First argument to waterfall must be an array of functions"));
                    if (!n.length) return t();
                    var u = 0;
                    r([])
                }
                var tt, et = Math.max,
                    rt = i("length"),
                    ut = "[object Function]",
                    it = "[object GeneratorFunction]",
                    ot = Object.prototype,
                    ct = ot.toString,
                    ft = 9007199254740991,
                    at = "function" == typeof Symbol && Symbol.iterator,
                    lt = Object.getPrototypeOf,
                    st = h(lt, Object),
                    pt = Object.prototype,
                    ht = pt.hasOwnProperty,
                    yt = Object.keys,
                    vt = h(yt, Object),
                    mt = "[object Arguments]",
                    dt = Object.prototype,
                    gt = dt.hasOwnProperty,
                    bt = dt.toString,
                    St = dt.propertyIsEnumerable,
                    jt = Array.isArray,
                    kt = "[object String]",
                    wt = Object.prototype,
                    Lt = wt.toString,
                    Et = 9007199254740991,
                    Ot = /^(?:0|[1-9]\d*)$/,
                    xt = Object.prototype,
                    At = T(I, 1 / 0),
                    _t = B(M),
                    It = u(_t),
                    Tt = V(M),
                    Ft = T(Tt, 1),
                    zt = u(Ft),
                    Bt = e(function (n, t) {
                        return e(function (e) {
                            return n.apply(null, t.concat(e))
                        })
                    }),
                    Mt = C(),
                    Vt = "object" == typeof global && global && global.Object === Object && global,
                    qt = "object" == typeof self && self && self.Object === Object && self,
                    $t = Vt || qt || Function("return this")(),
                    Ct = $t.Symbol,
                    Dt = "[object Symbol]",
                    Pt = Object.prototype,
                    Rt = Pt.toString,
                    Ut = 1 / 0,
                    Qt = Ct ? Ct.prototype : void 0,
                    Wt = Qt ? Qt.toString : void 0,
                    Gt = "\\ud800-\\udfff",
                    Ht = "\\u0300-\\u036f\\ufe20-\\ufe23",
                    Jt = "\\u20d0-\\u20f0",
                    Kt = "\\ufe0e\\ufe0f",
                    Nt = "[" + Gt + "]",
                    Xt = "[" + Ht + Jt + "]",
                    Yt = "\\ud83c[\\udffb-\\udfff]",
                    Zt = "(?:" + Xt + "|" + Yt + ")",
                    ne = "[^" + Gt + "]",
                    te = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                    ee = "[\\ud800-\\udbff][\\udc00-\\udfff]",
                    re = "\\u200d",
                    ue = Zt + "?",
                    ie = "[" + Kt + "]?",
                    oe = "(?:" + re + "(?:" + [ne, te, ee].join("|") + ")" + ie + ue + ")*",
                    ce = ie + ue + oe,
                    fe = "(?:" + [ne + Xt + "?", Xt, te, ee, Nt].join("|") + ")",
                    ae = RegExp(Yt + "(?=" + Yt + ")|" + fe + ce, "g"),
                    le = /^\s+|\s+$/g,
                    se = /^(function)?\s*[^\(]*\(\s*([^\)]*)\)/m,
                    pe = /,/,
                    he = /(=.+)?(\s*)$/,
                    ye = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
                    ve = "function" == typeof setImmediate && setImmediate,
                    me = "object" == typeof process && "function" == typeof process.nextTick;
                tt = ve ? setImmediate : me ? process.nextTick : un;
                var de = on(tt);
                cn.prototype.removeLink = function (n) {
                    return n.prev ? n.prev.next = n.next : this.head = n.next, n.next ? n.next.prev = n
                        .prev : this.tail = n.prev, n.prev = n.next = null, this.length -= 1, n
                }, cn.prototype.empty = cn, cn.prototype.insertAfter = function (n, t) {
                    t.prev = n, t.next = n.next, n.next ? n.next.prev = t : this.tail = t, n.next = t,
                        this.length += 1
                }, cn.prototype.insertBefore = function (n, t) {
                    t.prev = n.prev, t.next = n, n.prev ? n.prev.next = t : this.head = t, n.prev = t,
                        this.length += 1
                }, cn.prototype.unshift = function (n) {
                    this.head ? this.insertBefore(this.head, n) : fn(this, n)
                }, cn.prototype.push = function (n) {
                    this.tail ? this.insertAfter(this.tail, n) : fn(this, n)
                }, cn.prototype.shift = function () {
                    return this.head && this.removeLink(this.head)
                }, cn.prototype.pop = function () {
                    return this.tail && this.removeLink(this.tail)
                };
                var ge, be = T(I, 1),
                    Se = e(function (n) {
                        return e(function (t) {
                            var r = this,
                                u = t[t.length - 1];
                            "function" == typeof u ? t.pop() : u = l, sn(n, t, function (n, t,
                                u) {
                                t.apply(r, n.concat([e(function (n, t) {
                                    u(n, t)
                                })]))
                            }, function (n, t) {
                                u.apply(r, [n].concat(t))
                            })
                        })
                    }),
                    je = e(function (n) {
                        return Se.apply(null, n.reverse())
                    }),
                    ke = B(pn),
                    we = hn(pn),
                    Le = e(function (n) {
                        var t = [null].concat(n);
                        return r(function (n, e) {
                            return e.apply(this, t)
                        })
                    }),
                    Ee = vn(z, yn, mn),
                    Oe = vn(I, yn, mn),
                    xe = vn(be, yn, mn),
                    Ae = dn("dir"),
                    _e = T(Ln, 1),
                    Ie = vn(z, On, On),
                    Te = vn(I, On, On),
                    Fe = T(Te, 1),
                    ze = B(xn),
                    Be = V(xn),
                    Me = T(Be, 1),
                    Ve = dn("log"),
                    qe = T(_n, 1 / 0),
                    $e = T(_n, 1);
                ge = me ? process.nextTick : ve ? setImmediate : un;
                var Ce = on(ge),
                    De = Array.prototype.slice,
                    Pe = B(Dn),
                    Re = V(Dn),
                    Ue = T(Re, 1),
                    Qe = vn(z, Boolean, yn),
                    We = vn(I, Boolean, yn),
                    Ge = T(We, 1),
                    He = Math.ceil,
                    Je = Math.max,
                    Ke = T(Kn, 1 / 0),
                    Ne = T(Kn, 1),
                    Xe = {
                        applyEach: It,
                        applyEachSeries: zt,
                        apply: Bt,
                        asyncify: q,
                        auto: Q,
                        autoInject: rn,
                        cargo: ln,
                        compose: je,
                        concat: ke,
                        concatSeries: we,
                        constant: Le,
                        detect: Ee,
                        detectLimit: Oe,
                        detectSeries: xe,
                        dir: Ae,
                        doDuring: gn,
                        doUntil: Sn,
                        doWhilst: bn,
                        during: jn,
                        each: wn,
                        eachLimit: Ln,
                        eachOf: z,
                        eachOfLimit: I,
                        eachOfSeries: be,
                        eachSeries: _e,
                        ensureAsync: En,
                        every: Ie,
                        everyLimit: Te,
                        everySeries: Fe,
                        filter: ze,
                        filterLimit: Be,
                        filterSeries: Me,
                        forever: An,
                        log: Ve,
                        map: _t,
                        mapLimit: Tt,
                        mapSeries: Ft,
                        mapValues: qe,
                        mapValuesLimit: _n,
                        mapValuesSeries: $e,
                        memoize: Tn,
                        nextTick: Ce,
                        parallel: zn,
                        parallelLimit: Bn,
                        priorityQueue: Vn,
                        queue: Mn,
                        race: qn,
                        reduce: sn,
                        reduceRight: $n,
                        reflect: Cn,
                        reflectAll: Pn,
                        reject: Pe,
                        rejectLimit: Re,
                        rejectSeries: Ue,
                        retry: Un,
                        retryable: Qn,
                        seq: Se,
                        series: Wn,
                        setImmediate: de,
                        some: Qe,
                        someLimit: We,
                        someSeries: Ge,
                        sortBy: Gn,
                        timeout: Hn,
                        times: Ke,
                        timesLimit: Kn,
                        timesSeries: Ne,
                        transform: Nn,
                        unmemoize: Xn,
                        until: Zn,
                        waterfall: nt,
                        whilst: Yn,
                        all: Ie,
                        any: Qe,
                        forEach: wn,
                        forEachSeries: _e,
                        forEachLimit: Ln,
                        forEachOf: z,
                        forEachOfSeries: be,
                        forEachOfLimit: I,
                        inject: sn,
                        foldl: sn,
                        foldr: $n,
                        select: ze,
                        selectLimit: Be,
                        selectSeries: Me,
                        wrapSync: q
                    };
                n["default"] = Xe, n.applyEach = It, n.applyEachSeries = zt, n.apply = Bt, n.asyncify = q,
                    n.auto = Q, n.autoInject = rn, n.cargo = ln, n.compose = je, n.concat = ke, n.concatSeries =
                    we, n.constant = Le, n.detect = Ee, n.detectLimit = Oe, n.detectSeries = xe, n.dir = Ae,
                    n.doDuring = gn, n.doUntil = Sn, n.doWhilst = bn, n.during = jn, n.each = wn, n.eachLimit =
                    Ln, n.eachOf = z, n.eachOfLimit = I, n.eachOfSeries = be, n.eachSeries = _e, n.ensureAsync =
                    En, n.every = Ie, n.everyLimit = Te, n.everySeries = Fe, n.filter = ze, n.filterLimit =
                    Be, n.filterSeries = Me, n.forever = An, n.log = Ve, n.map = _t, n.mapLimit = Tt, n.mapSeries =
                    Ft, n.mapValues = qe, n.mapValuesLimit = _n, n.mapValuesSeries = $e, n.memoize = Tn, n.nextTick =
                    Ce, n.parallel = zn, n.parallelLimit = Bn, n.priorityQueue = Vn, n.queue = Mn, n.race =
                    qn, n.reduce = sn, n.reduceRight = $n, n.reflect = Cn, n.reflectAll = Pn, n.reject = Pe,
                    n.rejectLimit = Re, n.rejectSeries = Ue, n.retry = Un, n.retryable = Qn, n.seq = Se, n.series =
                    Wn, n.setImmediate = de, n.some = Qe, n.someLimit = We, n.someSeries = Ge, n.sortBy =
                    Gn, n.timeout = Hn, n.times = Ke, n.timesLimit = Kn, n.timesSeries = Ne, n.transform =
                    Nn, n.unmemoize = Xn, n.until = Zn, n.waterfall = nt, n.whilst = Yn, n.all = Ie, n.allLimit =
                    Te, n.allSeries = Fe, n.any = Qe, n.anyLimit = We, n.anySeries = Ge, n.find = Ee, n.findLimit =
                    Oe, n.findSeries = xe, n.forEach = wn, n.forEachSeries = _e, n.forEachLimit = Ln, n.forEachOf =
                    z, n.forEachOfSeries = be, n.forEachOfLimit = I, n.inject = sn, n.foldl = sn, n.foldr =
                    $n, n.select = ze, n.selectLimit = Be, n.selectSeries = Me, n.wrapSync = q
            });
            //# sourceMappingURL=async.min.map

            Rally.launchApp('CustomApp', {
                name: "program-velocity-metrics",
                parentRepos: ""
            });

        });
    </script>


    <style type="text/css">
        .app {
            /* Add app styles here */
        }
    </style>
</head>

<body></body>

</html>