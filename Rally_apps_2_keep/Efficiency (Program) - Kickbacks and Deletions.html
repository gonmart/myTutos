<!DOCTYPE html>
<html>

<head>
    <title>Kickbacks and Deletions</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Mon Jun 01 2015 08:12:21 GMT-0600 (MDT) -->

    <script type="text/javascript">
        var APP_BUILD_DATE = "Mon Jun 01 2015 08:12:21 GMT-0600 (MDT)";
        var CHECKSUM = 66405745459;
    </script>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {

            /* Blob.js
             * A Blob implementation.
             * 2014-05-31
             *
             * By Eli Grey, http://eligrey.com
             * By Devin Samarin, https://github.com/eboyjr
             * License: X11/MIT
             *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
             */

            /*global self, unescape */
            /*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
             plusplus: true */

            /*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

            (function (view) {
                "use strict";

                view.URL = view.URL || view.webkitURL;

                if (view.Blob && view.URL) {
                    try {
                        new Blob;
                        return;
                    } catch (e) {}
                }

                // Internally we use a BlobBuilder implementation to base Blob off of
                // in order to support older browsers that only have BlobBuilder
                var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (
                    function (view) {
                        var
                            get_class = function (object) {
                                return Object.prototype.toString.call(object).match(
                                    /^\[object\s(.*)\]$/)[1];
                            },
                            FakeBlobBuilder = function BlobBuilder() {
                                this.data = [];
                            },
                            FakeBlob = function Blob(data, type, encoding) {
                                this.data = data;
                                this.size = data.length;
                                this.type = type;
                                this.encoding = encoding;
                            },
                            FBB_proto = FakeBlobBuilder.prototype,
                            FB_proto = FakeBlob.prototype,
                            FileReaderSync = view.FileReaderSync,
                            FileException = function (type) {
                                this.code = this[this.name = type];
                            },
                            file_ex_codes = (
                                "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR " +
                                "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
                            ).split(" "),
                            file_ex_code = file_ex_codes.length,
                            real_URL = view.URL || view.webkitURL || view,
                            real_create_object_URL = real_URL.createObjectURL,
                            real_revoke_object_URL = real_URL.revokeObjectURL,
                            URL = real_URL,
                            btoa = view.btoa,
                            atob = view.atob

                            ,
                            ArrayBuffer = view.ArrayBuffer,
                            Uint8Array = view.Uint8Array;
                        FakeBlob.fake = FB_proto.fake = true;
                        while (file_ex_code--) {
                            FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
                        }
                        if (!real_URL.createObjectURL) {
                            URL = view.URL = {};
                        }
                        URL.createObjectURL = function (blob) {
                            var
                                type = blob.type,
                                data_URI_header;
                            if (type === null) {
                                type = "application/octet-stream";
                            }
                            if (blob instanceof FakeBlob) {
                                data_URI_header = "data:" + type;
                                if (blob.encoding === "base64") {
                                    return data_URI_header + ";base64," + blob.data;
                                } else if (blob.encoding === "URI") {
                                    return data_URI_header + "," + decodeURIComponent(blob.data);
                                }
                                if (btoa) {
                                    return data_URI_header + ";base64," + btoa(blob.data);
                                } else {
                                    return data_URI_header + "," + encodeURIComponent(blob.data);
                                }
                            } else if (real_create_object_URL) {
                                return real_create_object_URL.call(real_URL, blob);
                            }
                        };
                        URL.revokeObjectURL = function (object_URL) {
                            if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
                                real_revoke_object_URL.call(real_URL, object_URL);
                            }
                        };
                        FBB_proto.append = function (data /*, endings*/ ) {
                            var bb = this.data;
                            // decode data to a binary string
                            if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
                                var
                                    str = "",
                                    buf = new Uint8Array(data),
                                    i = 0,
                                    buf_len = buf.length;
                                for (; i < buf_len; i++) {
                                    str += String.fromCharCode(buf[i]);
                                }
                                bb.push(str);
                            } else if (get_class(data) === "Blob" || get_class(data) === "File") {
                                if (FileReaderSync) {
                                    var fr = new FileReaderSync;
                                    bb.push(fr.readAsBinaryString(data));
                                } else {
                                    // async FileReader won't work as BlobBuilder is sync
                                    throw new FileException("NOT_READABLE_ERR");
                                }
                            } else if (data instanceof FakeBlob) {
                                if (data.encoding === "base64" && atob) {
                                    bb.push(atob(data.data));
                                } else if (data.encoding === "URI") {
                                    bb.push(decodeURIComponent(data.data));
                                } else if (data.encoding === "raw") {
                                    bb.push(data.data);
                                }
                            } else {
                                if (typeof data !== "string") {
                                    data += ""; // convert unsupported types to strings
                                }
                                // decode UTF-16 to binary string
                                bb.push(unescape(encodeURIComponent(data)));
                            }
                        };
                        FBB_proto.getBlob = function (type) {
                            if (!arguments.length) {
                                type = null;
                            }
                            return new FakeBlob(this.data.join(""), type, "raw");
                        };
                        FBB_proto.toString = function () {
                            return "[object BlobBuilder]";
                        };
                        FB_proto.slice = function (start, end, type) {
                            var args = arguments.length;
                            if (args < 3) {
                                type = null;
                            }
                            return new FakeBlob(
                                this.data.slice(start, args > 1 ? end : this.data.length), type,
                                this.encoding
                            );
                        };
                        FB_proto.toString = function () {
                            return "[object Blob]";
                        };
                        FB_proto.close = function () {
                            this.size = 0;
                            delete this.data;
                        };
                        return FakeBlobBuilder;
                    }(view));

                view.Blob = function Blob(blobParts, options) {
                    var type = options ? (options.type || "") : "";
                    var builder = new BlobBuilder();
                    if (blobParts) {
                        for (var i = 0, len = blobParts.length; i < len; i++) {
                            builder.append(blobParts[i]);
                        }
                    }
                    return builder.getBlob(type);
                };
            }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content ||
                this));

            /* FileSaver.js
             *  A saveAs() FileSaver implementation.
             *  2014-05-27
             *
             *  By Eli Grey, http://eligrey.com
             *  License: X11/MIT
             *    See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
             */

            /*global self */
            /*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

            /*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

            var saveAs = saveAs
                // IE 10+ (native saveAs)
                ||
                (typeof navigator !== "undefined" &&
                    navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
                // Everyone else
                ||
                (function (view) {
                    "use strict";
                    // IE <10 is explicitly unsupported
                    if (typeof navigator !== "undefined" &&
                        /MSIE [1-9]\./.test(navigator.userAgent)) {
                        return;
                    }
                    var
                        doc = view.document
                        // only get URL when necessary in case Blob.js hasn't overridden it yet
                        ,
                        get_URL = function () {
                            return view.URL || view.webkitURL || view;
                        },
                        save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
                        can_use_save_link = !view.externalHost && "download" in save_link,
                        click = function (node) {
                            var event = doc.createEvent("MouseEvents");
                            event.initMouseEvent(
                                "click", true, false, view, 0, 0, 0, 0, 0, false, false, false, false,
                                0, null
                            );
                            node.dispatchEvent(event);
                        },
                        webkit_req_fs = view.webkitRequestFileSystem,
                        req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem,
                        throw_outside = function (ex) {
                            (view.setImmediate || view.setTimeout)(function () {
                                throw ex;
                            }, 0);
                        },
                        force_saveable_type = "application/octet-stream",
                        fs_min_size = 0,
                        deletion_queue = [],
                        process_deletion_queue = function () {
                            var i = deletion_queue.length;
                            while (i--) {
                                var file = deletion_queue[i];
                                if (typeof file === "string") { // file is an object URL
                                    get_URL().revokeObjectURL(file);
                                } else { // file is a File
                                    file.remove();
                                }
                            }
                            deletion_queue.length = 0; // clear queue
                        },
                        dispatch = function (filesaver, event_types, event) {
                            event_types = [].concat(event_types);
                            var i = event_types.length;
                            while (i--) {
                                var listener = filesaver["on" + event_types[i]];
                                if (typeof listener === "function") {
                                    try {
                                        listener.call(filesaver, event || filesaver);
                                    } catch (ex) {
                                        throw_outside(ex);
                                    }
                                }
                            }
                        },
                        FileSaver = function (blob, name) {
                            // First try a.download, then web filesystem, then object URLs
                            var
                                filesaver = this,
                                type = blob.type,
                                blob_changed = false,
                                object_url, target_view, get_object_url = function () {
                                    var object_url = get_URL().createObjectURL(blob);
                                    deletion_queue.push(object_url);
                                    return object_url;
                                },
                                dispatch_all = function () {
                                    dispatch(filesaver, "writestart progress write writeend".split(" "));
                                }
                                // on any filesys errors revert to saving with object URLs
                                ,
                                fs_error = function () {
                                    // don't create more object URLs than needed
                                    if (blob_changed || !object_url) {
                                        object_url = get_object_url(blob);
                                    }
                                    if (target_view) {
                                        target_view.location.href = object_url;
                                    } else {
                                        window.open(object_url, "_blank");
                                    }
                                    filesaver.readyState = filesaver.DONE;
                                    dispatch_all();
                                },
                                abortable = function (func) {
                                    return function () {
                                        if (filesaver.readyState !== filesaver.DONE) {
                                            return func.apply(this, arguments);
                                        }
                                    };
                                },
                                create_if_not_found = {
                                    create: true,
                                    exclusive: false
                                },
                                slice;
                            filesaver.readyState = filesaver.INIT;
                            if (!name) {
                                name = "download";
                            }
                            if (can_use_save_link) {
                                object_url = get_object_url(blob);
                                save_link.href = object_url;
                                save_link.download = name;
                                click(save_link);
                                filesaver.readyState = filesaver.DONE;
                                dispatch_all();
                                return;
                            }
                            // Object and web filesystem URLs have a problem saving in Google Chrome when
                            // viewed in a tab, so I force save with application/octet-stream
                            // http://code.google.com/p/chromium/issues/detail?id=91158
                            if (view.chrome && type && type !== force_saveable_type) {
                                slice = blob.slice || blob.webkitSlice;
                                blob = slice.call(blob, 0, blob.size, force_saveable_type);
                                blob_changed = true;
                            }
                            // Since I can't be sure that the guessed media type will trigger a download
                            // in WebKit, I append .download to the filename.
                            // https://bugs.webkit.org/show_bug.cgi?id=65440
                            if (webkit_req_fs && name !== "download") {
                                name += ".download";
                            }
                            if (type === force_saveable_type || webkit_req_fs) {
                                target_view = view;
                            }
                            if (!req_fs) {
                                fs_error();
                                return;
                            }
                            fs_min_size += blob.size;
                            req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {
                                fs.root.getDirectory("saved", create_if_not_found, abortable(
                                    function (dir) {
                                        var save = function () {
                                            dir.getFile(name, create_if_not_found,
                                                abortable(function (file) {
                                                    file.createWriter(
                                                        abortable(
                                                            function (
                                                                writer) {
                                                                writer.onwriteend =
                                                                    function (
                                                                        event
                                                                    ) {
                                                                        target_view
                                                                            .location
                                                                            .href =
                                                                            file
                                                                            .toURL();
                                                                        deletion_queue
                                                                            .push(
                                                                                file
                                                                            );
                                                                        filesaver
                                                                            .readyState =
                                                                            filesaver
                                                                            .DONE;
                                                                        dispatch
                                                                            (
                                                                                filesaver,
                                                                                "writeend",
                                                                                event
                                                                            );
                                                                    };
                                                                writer.onerror =
                                                                    function () {
                                                                        var
                                                                            error =
                                                                            writer
                                                                            .error;
                                                                        if (
                                                                            error
                                                                            .code !==
                                                                            error
                                                                            .ABORT_ERR
                                                                        ) {
                                                                            fs_error
                                                                                ();
                                                                        }
                                                                    };
                                                                "writestart progress write abort"
                                                                .split(
                                                                    " "
                                                                ).forEach(
                                                                    function (
                                                                        event
                                                                    ) {
                                                                        writer
                                                                            [
                                                                                "on" +
                                                                                event
                                                                            ] =
                                                                            filesaver[
                                                                                "on" +
                                                                                event
                                                                            ];
                                                                    }
                                                                );
                                                                writer.write(
                                                                    blob
                                                                );
                                                                filesaver
                                                                    .abort =
                                                                    function () {
                                                                        writer
                                                                            .abort();
                                                                        filesaver
                                                                            .readyState =
                                                                            filesaver
                                                                            .DONE;
                                                                    };
                                                                filesaver
                                                                    .readyState =
                                                                    filesaver
                                                                    .WRITING;
                                                            }),
                                                        fs_error);
                                                }), fs_error);
                                        };
                                        dir.getFile(name, {
                                            create: false
                                        }, abortable(function (file) {
                                            // delete file if it already exists
                                            file.remove();
                                            save();
                                        }), abortable(function (ex) {
                                            if (ex.code === ex.NOT_FOUND_ERR) {
                                                save();
                                            } else {
                                                fs_error();
                                            }
                                        }));
                                    }), fs_error);
                            }), fs_error);
                        },
                        FS_proto = FileSaver.prototype,
                        saveAs = function (blob, name) {
                            return new FileSaver(blob, name);
                        };
                    FS_proto.abort = function () {
                        var filesaver = this;
                        filesaver.readyState = filesaver.DONE;
                        dispatch(filesaver, "abort");
                    };
                    FS_proto.readyState = FS_proto.INIT = 0;
                    FS_proto.WRITING = 1;
                    FS_proto.DONE = 2;

                    FS_proto.error =
                        FS_proto.onwritestart =
                        FS_proto.onprogress =
                        FS_proto.onwrite =
                        FS_proto.onabort =
                        FS_proto.onerror =
                        FS_proto.onwriteend =
                        null;

                    view.addEventListener("unload", process_deletion_queue, false);
                    saveAs.unload = function () {
                        process_deletion_queue();
                        view.removeEventListener("unload", process_deletion_queue, false);
                    };
                    return saveAs;
                }(
                    typeof self !== "undefined" && self ||
                    typeof window !== "undefined" && window ||
                    this.content
                ));
            // `self` is undefined in Firefox for Android content script context
            // while `this` is nsIContentFrameMessageManager
            // with an attribute `content` that corresponds to the window

            if (typeof module !== "undefined" && module !== null) {
                module.exports = saveAs;
            } else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
                define([], function () {
                    return saveAs;
                });
            }

            /**
             * A link that pops up a version dialog box
             */

            Ext.define('Rally.technicalservices.InfoLink', {
                extend: 'Ext.Component',
                alias: 'widget.tsinfolink',

                /**
                 * @cfg {String} informationHtml
                 * Additional text to be displayed on the popup dialog (for exmaple,
                 * to add a description of the app's use or functionality)
                 */
                informationHtml: null,

                /**
                 * 
                 * cfg {String} title
                 * The title for the dialog box
                 */
                title: "Build Information",

                renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

                initComponent: function () {
                    this.callParent(arguments);

                },

                onRender: function () {
                    this.callParent(arguments);
                    this.mon(this.el, 'click', this.onClick, this);
                },
                _generateChecksum: function (string) {
                    var chk = 0x12345678,
                        i;
                    string = string.replace(/var CHECKSUM = .*;/, "");
                    string = string.replace(/\s/g, ""); //Remove all whitespace from the string.

                    for (i = 0; i < string.length; i++) {
                        chk += (string.charCodeAt(i) * i);
                    }

                    return chk;
                },
                _checkChecksum: function (container) {
                    var me = this;
                    Ext.Ajax.request({
                        url: document.URL,
                        params: {
                            id: 1
                        },
                        success: function (response) {
                            text = response.responseText;
                            if (CHECKSUM) {
                                if (CHECKSUM !== me._generateChecksum(text)) {
                                    console.log("Checksums don't match!");
                                    if (me.dialog) {
                                        me.dialog.add({
                                            xtype: 'container',
                                            html: 'Checksums do not match'
                                        });
                                    }
                                }
                            }
                        }
                    });
                },
                onClick: function (e) {
                    var me = this;
                    this._checkChecksum(this);

                    var dialog_items = [];

                    if (this.informationHtml) {
                        dialog_items.push({
                            xtype: 'container',
                            html: this.informationHtml
                        });
                    }

                    dialog_items.push({
                        xtype: 'container',
                        html: "This app was created by the Rally Technical Services Team."
                    });

                    if (APP_BUILD_DATE) {
                        dialog_items.push({
                            xtype: 'container',
                            html: 'Build date/time: ' + APP_BUILD_DATE
                        });
                    }

                    if (this.dialog) {
                        this.dialog.destroy();
                    }
                    this.dialog = Ext.create('Rally.ui.dialog.Dialog', {
                        defaults: {
                            padding: 5,
                            margin: 5
                        },
                        closable: true,
                        draggable: true,
                        title: me.title,
                        items: dialog_items
                    });
                    this.dialog.show();
                }
            });

            /*
             */
            Ext.define('Rally.technicalservices.Logger', {
                constructor: function (config) {
                    Ext.apply(this, config);
                },
                log: function (args) {
                    var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
                    //var output_args = arguments;
                    //output_args.unshift( [ "[ " + timestamp + " ]" ] );
                    //output_args = Ext.Array.push(output_args,arguments);

                    var output_args = [];
                    output_args = Ext.Array.push(output_args, [timestamp]);
                    output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments, 0));

                    window.console && console.log.apply(console, output_args);
                }

            });

            Ext.define('Rally.technicalservices.data.Chunker', {
                MAX_CHUNK_SIZE: 25,
                logger: new Rally.technicalservices.Logger(),
                config: {
                    fetch: null,
                    find: null,
                    chunkField: null,
                    chunkOids: null
                },
                constructor: function (config) {
                    this.initConfig(config);
                },
                load: function () {
                    var deferred = Ext.create('Deft.Deferred');
                    var oids = this.chunkOids;
                    var promises = [];

                    if (oids.length > this.MAX_CHUNK_SIZE) {
                        var start_idx = 0;
                        console.log('original array', oids);
                        while (start_idx < oids.length) {
                            chunk_values = oids.splice(start_idx, this.MAX_CHUNK_SIZE);
                            promises.push(this._fetchRecords(chunk_values));
                        }
                    } else {
                        promises.push(this._fetchRecords(oids));
                    }

                    if (promises.length == 0) {
                        deferred.resolve();
                    }
                    Deft.Promise.all(promises).then({
                        scope: this,
                        success: function (records) {
                            console.log('chunk rcors', records);
                            var data = _.flatten(records);
                            deferred.resolve(data);
                        },
                        failure: function () {
                            deferred.resolve([]);
                        }
                    });
                    return deferred;
                },
                _fetchRecords: function (object_ids) {
                    var deferred = Ext.create('Deft.Deferred');

                    var find = this.find;
                    find[this.chunkField] = {
                        $in: object_ids
                    }

                    Ext.create('Rally.data.lookback.SnapshotStore', {
                        fetch: this.fetch,
                        autoLoad: true,
                        find: find,
                        removeUnauthorizedSnapshots: true,
                        limit: 'Infinity',
                        listeners: {
                            scope: this,
                            load: function (store, records, success) {
                                this.logger.log('chunking success', success);
                                deferred.resolve(records);
                            }
                        }
                    });
                    return deferred;
                }
            });

            Ext.define('Rally.technicalservices.FileUtilities', {
                singleton: true,
                logger: new Rally.technicalservices.Logger(),
                saveHTMLToFile: function (html, file_name, type_object) {
                    if (type_object == undefined) {
                        type_object = {
                            type: 'text/html;charset=utf-8'
                        };
                    }
                    var blob = new Blob([html], type_object);
                    saveAs(blob, file_name);
                },
                saveAs: function (text, file_name, type_object) {
                    if (type_object == undefined) {
                        type_object = {
                            type: 'text/plain'
                        };
                    }
                    var blob = new Blob([text], type_object);
                    saveAs(blob, file_name);
                },
                saveTextAsFile: function (textToWrite, fileName) {
                    var textFileAsBlob = new Blob([textToWrite], {
                        type: 'text/plain'
                    });
                    var fileNameToSaveAs = fileName;

                    if (this.detectIE() >= 10) {
                        console.log(window.navigator);
                        window.navigator.msSaveBlob(textFileAsBlob, fileNameToSaveAs);
                    } else {

                        var downloadLink = document.createElement("a");
                        downloadLink.download = fileNameToSaveAs;
                        downloadLink.innerHTML = "Download File";
                        if (window.webkitURL != null) {
                            // Chrome allows the link to be clicked
                            // without actually adding it to the DOM.
                            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
                        } else {
                            // Firefox requires the link to be added to the DOM
                            // before it can be clicked.
                            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
                            downloadLink.onclick = this.destroyClickedElement;
                            downloadLink.style.display = "none";
                            document.body.appendChild(downloadLink);
                        }
                        downloadLink.click();
                    }
                },
                destroyClickedElement: function (event) {
                    document.body.removeChild(event.target);
                },
                convertDataArrayToCSVText: function (data_array, requestedFieldHash) {

                    var text = '';
                    Ext.each(Object.keys(requestedFieldHash), function (key) {
                        text += requestedFieldHash[key] + ',';
                    });
                    text = text.replace(/,$/, '\n');

                    Ext.each(data_array, function (d) {
                        Ext.each(Object.keys(requestedFieldHash), function (key) {
                            if (d[key]) {
                                if (typeof d[key] === 'object') {
                                    if (d[key].FormattedID) {
                                        text += Ext.String.format("\"{0}\",", d[key]
                                            .FormattedID);
                                    } else if (d[key].Name) {
                                        text += Ext.String.format("\"{0}\",", d[key]
                                            .Name);
                                    } else if (!isNaN(Date.parse(d[key]))) {
                                        text += Ext.String.format("\"{0}\",", Rally
                                            .util.DateTime.formatWithDefaultDateTime(
                                                d[key]));
                                    } else {
                                        text += Ext.String.format("\"{0}\",", d[key]
                                            .toString());
                                    }
                                } else {
                                    text += Ext.String.format("\"{0}\",", d[key]);
                                }
                            } else {
                                text += ',';
                            }
                        }, this);
                        text = text.replace(/,$/, '\n');
                    }, this);
                    return text;
                },
                scrubStringForXML: function (string) {
                    console.log('scrub', string);
                    if (string) {
                        var scrubbed_string = string.replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/"/g, '&quot;')
                            .replace(/'/g, '&apos;');
                        return scrubbed_string;
                    }
                    return '';
                },
                detectIE: function () {
                    var ua = window.navigator.userAgent;

                    var msie = ua.indexOf('MSIE ');
                    if (msie > 0) {
                        // IE 10 or older => return version number
                        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
                    }

                    var trident = ua.indexOf('Trident/');
                    if (trident > 0) {
                        // IE 11 => return version number
                        var rv = ua.indexOf('rv:');
                        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
                    }

                    var edge = ua.indexOf('Edge/');
                    if (edge > 0) {
                        // IE 12 => return version number
                        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
                    }

                    // other browser
                    return false;
                },
                //https://msdn.microsoft.com/en-us/library/ie/hh673542(v=vs.85).aspx
                getCSVFromGrid: function (grid) {
                    var store = grid.getStore();

                    var columns = grid.columns;
                    var column_names = [];
                    var headers = [];

                    var csv = [];

                    Ext.Array.each(columns, function (column) {
                        if (column.dataIndex || column.renderer) {
                            column_names.push(column.dataIndex);
                            if (column.csvText) {
                                headers.push(column.csvText);
                            } else {
                                headers.push(column.text);
                            }
                        }
                    });

                    csv.push('"' + headers.join('","') + '"');

                    var mock_meta_data = {
                        align: "right",
                        classes: [],
                        cellIndex: 9,
                        column: null,
                        columnIndex: 9,
                        innerCls: undefined,
                        recordIndex: 5,
                        rowIndex: 5,
                        style: "",
                        tdAttr: "",
                        tdCls: "x-grid-cell x-grid-td x-grid-cell-headerId-gridcolumn-1029 x-grid-cell-last x-unselectable",
                        unselectableAttr: "unselectable='on'"
                    };

                    _.each(store.getData().items, function (record) {
                        var node_values = [];
                        Ext.Array.each(columns, function (column) {
                            if (column.dataIndex) {
                                var column_name = column.dataIndex;
                                var display_value = record.get(column_name);

                                if (!column._csvIgnoreRender && column.renderer) {
                                    display_value = column.renderer(display_value,
                                        mock_meta_data, record, 0, 0, store,
                                        grid.getView());
                                }
                                node_values.push(display_value);
                            } else {
                                var display_value = null;
                                if (!column._csvIgnoreRender && column.renderer) {
                                    display_value = column.renderer(display_value,
                                        mock_meta_data, record, record, 0, 0,
                                        store, grid.getView());
                                    node_values.push(display_value);
                                }
                            }
                        }, this);
                        csv.push('"' + node_values.join('","') + '"');
                    });
                    return csv.join('\r\n');
                }
            });


            Ext.define('Rally.technicalservices.KickbackCalculator', {
                logger: new Rally.technicalservices.Logger(),
                config: {
                    kickbackField: 'ScheduleState',
                    kickbackPrecedence: [],
                    startDate: null,
                    endDate: null,
                    granularity: "month",
                    dateFormat: "M yyyy",
                    kickbackThreshholdInSeconds: 300,
                    missingOids: []
                },

                snapsByOid: {},

                constructor: function (config) {
                    this.mergeConfig(config);
                },
                runCalculation: function (snapshots) {

                    var snaps_by_oid = Rally.technicalservices.Toolbox.aggregateSnapsByOidForModel(
                        snapshots);
                    var date_buckets = Rally.technicalservices.Toolbox.getDateBuckets(this.startDate,
                        this.endDate, this.granularity);

                    var kickBackData = [],
                        deletions = [];

                    Ext.Object.each(snaps_by_oid, function (oid, snaps) {
                        var kbd = this._getKickbackData(snaps, this.kickbackField, this.kickbackPrecedence);
                        if (kbd) {
                            kickBackData.push(kbd);
                        }
                    }, this);

                    var series = this._getSerieses(kickBackData, date_buckets, this.granularity);

                    categories = Rally.technicalservices.Toolbox.formatDateBuckets(date_buckets,
                        this.dateFormat);

                    //{formattedID: formattedID, name: name, kickbacks: kickbacks, deletedDate: deleteDate, deletedState: deletedState};
                    var kickBackDataExport = [];
                    Ext.each(kickBackData, function (kbd) {
                        var formattedID = kbd.formattedID,
                            name = kbd.name,
                            type = kbd.type || null;

                        if (kbd.deletedDate) {
                            kickBackDataExport.push({
                                formattedID: formattedID,
                                name: name,
                                type: type,
                                lastState: kbd.deletedState,
                                currentState: null,
                                date: kbd.deletedDate,
                                deletion: true
                            });
                        }
                        _.each(kbd.kickbacks, function (kb) {
                            kickBackDataExport.push({
                                formattedID: formattedID,
                                name: name,
                                type: type,
                                lastState: kb.lastState,
                                currentState: kb.currentState,
                                date: kb.date,
                                deletion: false
                            });
                        });
                    });
                    this.kickBackDataExport = kickBackDataExport;

                    return {
                        series: series,
                        categories: categories
                    }
                },
                _getKickbackData: function (snaps, field, precedence) {

                    //Assumes snaps are stored in ascending date order.
                    var previous_state_index = -1;
                    var state_index = -1;
                    var seconds = null;
                    var days = null;
                    var include = false;

                    //First check for deletions
                    var deletions = [];
                    var kickbacks = [];

                    var lastSnap = snaps.slice(-1)[0],
                        lastValidTo = Rally.util.DateTime.fromIsoString(lastSnap._ValidTo),
                        deleteDate = null,
                        deletedState = null,
                        formattedID = lastSnap.FormattedID,
                        objectID = lastSnap.ObjectID,
                        name = lastSnap.Name;

                    if (lastValidTo < new Date() && Ext.Array.contains(this.missingOids, objectID)) {
                        deleteDate = lastValidTo;
                        deletedState = lastSnap[field];
                    }

                    var current_kickback = null;
                    Ext.each(snaps, function (snap) {
                        if (snap[field]) {
                            previous_state_index = state_index;
                            state_index = _.indexOf(precedence, snap[field]);
                        }

                        var validFrom = Rally.util.DateTime.fromIsoString(snap._ValidFrom);

                        if (previous_state_index > state_index) {
                            //todo if current kickback exists, then we don't want to start the clock et
                            current_kickback = {
                                date: validFrom,
                                lastState: precedence[previous_state_index],
                                lastStateIndex: previous_state_index,
                                currentState: snap[field],
                                currentStateIndex: state_index
                            };
                            //kickbacks.push(_.clone(current_kickback));
                        } else {
                            if (current_kickback) {
                                if (Rally.util.DateTime.getDifference(validFrom,
                                        current_kickback.date, "second") > this.kickbackThreshholdInSeconds) {
                                    kickbacks.push(_.clone(current_kickback));
                                    current_kickback = null;
                                } else {
                                    if (state_index >= current_kickback.lastStateIndex) {
                                        //this fell within the threshhold for the kickback, so throw it away
                                        current_kickback = null;
                                    }
                                }
                            }
                        }
                    }, this);

                    //handle scenario where the kickback was the last snapshot
                    if (current_kickback) {
                        kickbacks.push(current_kickback);
                    }

                    if (kickbacks.length > 0 || deleteDate) {
                        return {
                            objectID: objectID,
                            formattedID: formattedID,
                            name: name,
                            kickbacks: kickbacks,
                            deletedDate: deleteDate,
                            deletedState: deletedState
                        };
                    }
                    return null;

                },
                _getSerieses: function (kickbackData, date_buckets, granularity) {
                    var kickbackCount = [],
                        deletedCount = [];

                    for (var i = 0; i < date_buckets.length; i++) {
                        kickbackCount[i] = 0;
                        deletedCount[i] = 0;
                    }

                    Ext.each(kickbackData, function (kdata) {
                        for (var i = 0; i < date_buckets.length; i++) {
                            if (kdata.deletedDate && kdata.deletedDate >= date_buckets[i] &&
                                kdata.deletedDate < Rally.util.DateTime.add(date_buckets[i],
                                    granularity, 1)) {
                                deletedCount[i]++;
                            }
                            Ext.each(kdata.kickbacks, function (kb) {
                                if (kb.date >= date_buckets[i] && kb.date < Rally.util
                                    .DateTime.add(date_buckets[i], granularity, 1)) {
                                    kickbackCount[i]++;
                                }
                            });
                        }
                    });

                    return [{
                        name: 'Kickbacks',
                        data: kickbackCount
                    }, {
                        name: 'Deletions',
                        data: deletedCount
                    }];
                }
            });

            Ext.define('Rally.technicalservices.KickbackChart', {
                extend: 'Rally.ui.chart.Chart',
                alias: 'widget.tskickbackchart',

                itemId: 'rally-chart',
                chartData: {},
                loadMask: false,
                chartConfig: {
                    chart: {
                        type: 'column'
                    },
                    title: {
                        text: 'Kickback Chart'
                    },
                    xAxis: {
                        tickInterval: 1,
                        title: {
                            text: 'Month'
                        }
                    },
                    yAxis: [{
                        title: {
                            text: 'Number of Events'
                        },
                        min: 0,
                        tickPositioner: function () {
                            console.log('_yAxisTickPositioner');
                            var positions = [],
                                tick = 0,
                                increment = Math.ceil((this.dataMax - this.dataMin) / 6);

                            for (tick; tick - increment <= this.dataMax; tick += increment) {
                                positions.push(tick);
                            }
                            return positions;
                        }
                    }],
                    plotOptions: {
                        series: {
                            dataLabels: {
                                format: '{point.y:.1f}'
                            },
                            marker: {
                                enabled: false
                            }
                        }
                    }
                },
                constructor: function (config) {
                    this.callParent(arguments);
                    if (config.title) {
                        this.chartConfig.title = config.title;
                    }
                }
            });

            Ext.override(Rally.ui.picker.FieldPicker, {
                _shouldShowField: function (field) {
                    var allowed_attribute_types = ['STATE', 'STRING'];
                    if (field.attributeDefinition) {
                        var attr_def = field.attributeDefinition;
                        //console.log(attr_def.ElementName, attr_def.AttributeType, attr_def);

                        var can_use = false;
                        if (attr_def.ElementName == "State") {
                            can_use = true;
                        }

                        if (attr_def.Constrained && Ext.Array.contains(allowed_attribute_types,
                                attr_def.AttributeType) && attr_def.ReadOnly == false) {
                            can_use = true;
                        }

                        if (attr_def.ElementName == "c_ProjectManager") {
                            can_use = false;
                        }


                        return can_use
                    }
                    return false;
                }
            });

            Ext.override(Ext.data.proxy.Server, {
                timeout: 60000,
                processResponse: function (success, operation, request, response, callback, scope) {
                    var me = this,
                        reader,
                        result;

                    if (success === true) {
                        reader = me.getReader();
                        reader.applyDefaults = operation.action === 'read';
                        result = reader.read(me.extractResponseData(response));

                        if (result.success !== false) {

                            Ext.apply(operation, {
                                response: response,
                                resultSet: result
                            });

                            operation.commitRecords(result.records);
                            operation.setCompleted();
                            operation.setSuccessful();
                        } else {
                            operation.setException(result.message);
                            me.fireEvent('exception', this, response, operation);
                        }
                    } else {
                        if (response) {
                            me.setException(operation, response);
                        }
                        me.fireEvent('exception', this, response, operation);
                    }


                    if (typeof callback == 'function') {
                        callback.call(scope || me, operation);
                    }

                    me.afterRequest(request, success);
                },


                setException: function (operation, response) {
                    operation.setException({
                        status: response.status,
                        statusText: response.statusText
                    });
                },


                extractResponseData: Ext.identityFn,


                applyEncoding: function (value) {
                    return Ext.encode(value);
                }
            });

            Ext.define('Rally.technicalservices.Toolbox', {
                singleton: true,
                /**
                 * Returns beginnig of month as date for the current time zone
                 *
                 */
                getBeginningOfMonthAsDate: function (dateInMonth) {
                    var year = dateInMonth.getFullYear();
                    var month = dateInMonth.getMonth();
                    return new Date(year, month, 1, 0, 0, 0, 0);
                },
                getEndOfMonthAsDate: function (dateInMonth) {
                    var year = dateInMonth.getFullYear();
                    var month = dateInMonth.getMonth();
                    var day = new Date(year, month + 1, 0).getDate();
                    return new Date(year, month, day, 0, 0, 0, 0);
                },
                aggregateSnapsByOid: function (snaps) {
                    //Return a hash of objects (key=ObjectID) with all snapshots for the object
                    var snaps_by_oid = {};
                    Ext.each(snaps, function (snap) {
                        var oid = snap.ObjectID || snap.get('ObjectID');
                        if (snaps_by_oid[oid] == undefined) {
                            snaps_by_oid[oid] = [];
                        }
                        snaps_by_oid[oid].push(snap);

                    });
                    return snaps_by_oid;
                },
                getCaseInsensitiveKey: function (obj, inputStr) {
                    var new_key = inputStr;
                    Ext.Object.each(obj, function (key, val) {
                        if (new_key.toLowerCase() == key.toLowerCase()) {
                            new_key = key;
                        }
                    });
                    return new_key;

                },
                aggregateSnapsByOidForModel: function (snaps) {
                    //Return a hash of objects (key=ObjectID) with all snapshots for the object
                    var snaps_by_oid = {};
                    Ext.each(snaps, function (snap) {
                        var oid = snap.ObjectID || snap.get('ObjectID');
                        if (snaps_by_oid[oid] == undefined) {
                            snaps_by_oid[oid] = [];
                        }
                        snaps_by_oid[oid].push(snap.getData());

                    });
                    return snaps_by_oid;
                },
                getDateBuckets: function (startDate, endDate, granularity) {

                    var bucketStartDate = Rally.technicalservices.Toolbox.getBeginningOfMonthAsDate(
                        startDate);
                    var bucketEndDate = Rally.technicalservices.Toolbox.getEndOfMonthAsDate(endDate);

                    var date = bucketStartDate;

                    var buckets = [];
                    while (date < bucketEndDate && bucketStartDate < bucketEndDate) {
                        buckets.push(date);
                        date = Rally.util.DateTime.add(date, granularity, 1);
                    }
                    return buckets;
                },
                formatDateBuckets: function (buckets, dateFormat) {
                    var categories = [];
                    Ext.each(buckets, function (bucket) {
                        categories.push(Rally.util.DateTime.format(bucket, dateFormat));
                    });
                    categories[categories.length - 1] += "*";
                    return categories;
                }
            });

            Ext.define('Rally.technicalservices.DropdownFieldCombobox', {
                requires: [],
                extend: 'Rally.ui.combobox.ComboBox',
                alias: 'widget.tsdropdownfieldcombobox',

                config: {
                    /**
                     * @cfg {Rally.data.Model/String} model (required) The model containing the specified field used to populate the store.
                     * Not required if field is an instance of {Rally.data.Field}.
                     */
                    model: undefined,

                    /**
                     * @cfg {Object} context An object specifying the scoping settings for retrieving the specified model
                     * If not specified the values provided by {Rally.env.Environment#getContext} will be used.
                     */
                    context: undefined,

                    queryMode: 'local',
                    editable: false,
                    valueField: 'value',
                    displayField: 'name',
                    lastQuery: ''
                },

                /**
                 * @constructor
                 */
                constructor: function (config) {

                    this.mergeConfig(config);

                    this.store = Ext.create('Ext.data.Store', {
                        fields: [this.valueField, this.displayField, 'fieldDefinition'],
                        data: []
                    });

                    return this.callParent([this.config]);
                },

                initComponent: function () {

                    this.callParent(arguments);

                    this.on('afterrender', this._onAfterRender, this);

                    if (this.model) {
                        if (Ext.isString(this.model)) {
                            this._fetchModel();
                        } else {
                            this._populateStore();
                        }
                    }
                },

                findRecordByValue: function (value) {
                    var record = this.findRecord(this.valueField, value);

                    if (!record && (value || '').indexOf('c_') !== 0) {
                        record = this.findRecord(this.valueField, 'c_' + value);
                    }

                    return record;
                },

                _fetchModel: function () {
                    Rally.data.ModelFactory.getModel({
                        context: this.context,
                        type: this.model,
                        success: this._onModelRetrieved,
                        scope: this
                    });
                },

                _onModelRetrieved: function (model) {
                    this.model = model;
                    this._populateStore();
                },

                _populateStore: function () {
                    if (!this.store) {
                        return;
                    }
                    var data = _.sortBy(
                        _.map(
                            _.filter(this.model.getFields(), this._isNotHidden),
                            this._convertFieldToLabelValuePair,
                            this
                        ),
                        'name'
                    );

                    this.store.loadRawData(data);
                    this.setDefaultValue();
                    this.onReady();
                },

                _isNotHidden: function (field) {
                    var attributeTypes = ['STRING', 'STATE', 'RATING'];

                    //Only allow State field for portfolio item types
                    if (/portfolioitem/.test(field.modelType)) {
                        return field.name == 'State';
                    }

                    if (!field.hidden && !field.ReadOnly &&
                        field.attributeDefinition && field.attributeDefinition.Constrained &&
                        (field.name == 'ScheduleState' || field.name == 'State' ||
                            /c_KanbanProcess/.test(field.name))) {
                        return true;
                    }
                    return false;
                },

                _convertFieldToLabelValuePair: function (field) {
                    var pair = {
                        fieldDefinition: field
                    };
                    pair[this.valueField] = field.name;
                    pair[this.displayField] = field.displayName;
                    return pair;
                },

                _onAfterRender: function () {
                    this._afterRender = true;
                    if (this._storeLoaded) {
                        this.fireEvent('ready', this);
                    }
                },

                onReady: function () {
                    this._storeLoaded = true;
                    if (this._afterRender) {
                        this.fireEvent('ready', this);
                    }
                },

                refreshWithNewModelType: function (type) {
                    this.model = type;
                    this._fetchModel();
                }
            });
            Ext.define("kickbacks-app", {
                extend: 'Rally.app.App',
                componentCls: 'app',
                logger: new Rally.technicalservices.Logger(),
                defaults: {
                    margin: 10
                },
                items: [{
                        xtype: 'container',
                        itemId: 'settings_box'
                    },
                    {
                        xtype: 'container',
                        itemId: 'message_box',
                        tpl: 'Hello, <tpl>{_refObjectName}</tpl>'
                    },
                    {
                        xtype: 'container',
                        itemId: 'selector_box',
                        layout: {
                            type: 'hbox'
                        }
                    },
                    {
                        xtype: 'container',
                        itemId: 'display_box'
                    },
                    {
                        xtype: 'tsinfolink'
                    }
                ],

                dateRangeStore: [{
                        name: 'Last Complete Month',
                        value: -1
                    },
                    {
                        name: 'Last 2 Complete Months',
                        value: -2
                    },
                    {
                        name: 'Last 3 Complete Months',
                        value: -3
                    },
                    {
                        name: 'Last 6 Complete Months',
                        value: -6
                    },
                    {
                        name: 'Last 12 Complete Months',
                        value: -12
                    }
                ],

                defaultDateRange: -3,
                config: {
                    defaultSettings: {
                        threshhold: 300
                    }
                },
                launch: function () {
                    if (this.isExternal()) {
                        this.showSettings(this.config);
                    } else {
                        this.onSettingsUpdate(this.getSettings()); //(this.config.type,this.config.pageSize,this.config.fetch,this.config.columns);
                    }
                },
                _updateApp: function () {

                    this._removeChart();
                    this._fetchData();
                },
                _fetchData: function () {
                    this.setLoading(true);
                    var field = this._getField(),
                        find = {
                            "_TypeHierarchy": this._getArtifactType(),
                            "_ValidTo": {
                                $gte: Rally.util.DateTime.toIsoString(this._getFromDate())
                            }
                        },
                        previousValueField = '_PreviousValues.' + field,
                        fetch = ['FormattedID', 'Name', field, previousValueField, 'Owner',
                            '_ValidFrom', '_ValidTo', '_UnformattedID'
                        ];

                    if (this.getContext().getProjectScopeDown()) {
                        find["_ProjectHierarchy"] = this.getContext().getProject().ObjectID;
                    } else {
                        find["Project"] = this.getContext().getProject().ObjectID;
                    }

                    var hydrate = ["Owner"];
                    if (field == 'ScheduleState' || field == 'State') {
                        hydrate.push(field);
                        hydrate.push(previousValueField);
                    }

                    var kb_store = Ext.create('Rally.data.lookback.SnapshotStore', {
                        findConfig: find,
                        fetch: fetch,
                        hydrate: hydrate,
                        removeUnauthorizedSnapshots: true,
                        limit: 'Infinity'
                    });

                    kb_store.load({
                        scope: this,
                        callback: this._kickbackStoreLoaded
                    });
                },
                _kickbackStoreLoaded: function (records, operation, success) {
                    this.logger.log('_kickbackStoreLoaded', records, operation, success);

                    this.setLoading(false);
                    if (!success) {
                        var msg = 'Failed to load data';
                        if (operation.error && operation.error.errors) {
                            msg += ': ' + operation.error.errors[0];
                        }
                        Rally.ui.notify.Notifier.showError({
                            message: msg
                        });
                        return;
                    }

                    var current = [],
                        all = [],
                        now = new Date();

                    _.each(records, function (r) {
                        var obj_id = r.get('ObjectID');
                        if (!Ext.Array.contains(all, obj_id)) {
                            all.push(obj_id);
                        }
                        var valid_to = Rally.util.DateTime.fromIsoString(r.get('_ValidTo'));
                        if (valid_to > now) {
                            current.push(obj_id);
                        }
                    });

                    //get disappearances
                    this.setLoading('Loading current items...');

                    var disappearing_oids = _.difference(all, current);
                    this._findCurrentItems(_.clone(disappearing_oids)).then({
                        scope: this,
                        success: function (currentRecords) {
                            this.setLoading(false);
                            this.logger.log('_findCurrentItems', currentRecords);
                            var current_oids = _.map(currentRecords, function (r) {
                                return r.get('ObjectID');
                            });
                            var missing_oids = _.difference(disappearing_oids,
                                current_oids);

                            var calc = Ext.create(
                                'Rally.technicalservices.KickbackCalculator', {
                                    missingOids: missing_oids,
                                    kickbackField: this._getField(),
                                    kickbackPrecedence: this._getFieldPrecedence(),
                                    startDate: this._getFromDate(),
                                    endDate: new Date(),
                                    kickbackThreshholdInSeconds: this.threshhold
                                });
                            var chart_data = calc.runCalculation(records);
                            this._addChart(chart_data);
                            this._addGrid(calc.kickBackDataExport);
                        },
                        failure: function (errorMsg) {
                            this.setLoading(false);
                        }
                    });
                },
                _findCurrentItems: function (oids) {
                    var deferred = Ext.create('Deft.Deferred');

                    var chunker = Ext.create('Rally.technicalservices.data.Chunker', {
                        fetch: ['ObjectID', 'FormattedID'],
                        find: {
                            __At: "current"
                        },
                        chunkField: "ObjectID",
                        chunkOids: oids
                    });

                    chunker.load().then({
                        scope: this,
                        success: function (data) {
                            deferred.resolve(data);
                        },
                        failure: function (errorMsg) {
                            deferred.reject(errorMsg);
                        }
                    });
                    return deferred;
                },
                _addGrid: function (kickbackData) {

                    var store = Ext.create('Rally.data.custom.Store', {
                        data: kickbackData,
                        pageSize: kickbackData.length + 1
                    });

                    this.down('#display_box').add({
                        xtype: 'container',
                        itemId: 'ct-label',
                        style: {
                            textAlign: 'right',
                            color: 'gray'
                        },
                        flex: 1,
                        html: '<i>' + kickbackData.length +
                            ' kickbacks and deletions found.</i>'
                    });

                    this.down('#display_box').add({
                        xtype: 'rallygrid',
                        itemId: 'rally-grid',
                        store: store,
                        showPagingToolbar: false,
                        showRowActionsColumn: false,
                        columnCfgs: [{
                                dataIndex: 'formattedID',
                                text: 'Formatted ID'
                            },
                            {
                                dataIndex: 'name',
                                text: 'Name',
                                flex: 1
                            },
                            {
                                dataIndex: 'lastState',
                                text: 'Original State'
                            },
                            {
                                dataIndex: 'currentState',
                                text: 'Changed-to State'
                            },
                            {
                                dataIndex: 'date',
                                text: 'Date',
                                flex: 1
                            },
                            {
                                dataIndex: 'deletion',
                                text: 'Deleted'
                            }
                        ]
                    });
                    this.down('#bt-export').setDisabled(false);
                },

                _removeChart: function () {
                    if (this.down('#rally-chart')) {
                        this.down('#rally-chart').destroy();
                        this.down('#rally-grid').destroy();
                        this.down('#ct-label').destroy();
                    }
                },
                _addChart: function (chartData) {
                    this._removeChart();
                    this.down('#display_box').add({
                        xtype: 'tskickbackchart',
                        itemId: 'rally-chart',
                        chartData: chartData,
                        title: 'Kickbacks and Deletions'
                    });
                },
                _getField: function () {
                    return this.down('#cb-field').getValue() || null;
                },
                _getFieldPrecedence: function () {
                    var allowedValues = this.down('#cb-field').getRecord().get('fieldDefinition').attributeDefinition
                        .AllowedValues;
                    return _.map(allowedValues, function (av) {
                        return av.StringValue
                    });
                },
                _getArtifactType: function () {
                    return this.down('#cb-artifact-type').getValue() || '';
                },
                _getFromDate: function () {
                    var monthsBack = this.down('#cb-date-range').getValue();
                    return Rally.util.DateTime.add(new Date(), "month", monthsBack);
                },
                _export: function () {
                    var grid = this.down('#rally-grid');
                    var csv = Rally.technicalservices.FileUtilities.getCSVFromGrid(grid);
                    Rally.technicalservices.FileUtilities.saveAs(csv, 'export.csv');

                },
                _addComponents: function () {

                    var date_store = Ext.create('Rally.data.custom.Store', {
                        data: this.dateRangeStore
                    });
                    this.down('#selector_box').add({
                        xtype: 'rallycombobox',
                        itemId: 'cb-date-range',
                        store: date_store,
                        displayField: 'name',
                        valueField: 'value',
                        fieldLabel: 'Date Range',
                        labelAlign: 'right',
                        labelWidth: 65,
                        width: 250,
                        value: this.defaultDateRange,
                        margin: 10
                    });

                    var objTypeFilters = [{
                            property: 'TypePath',
                            operator: 'contains',
                            value: 'PortfolioItem/'
                        },
                        {
                            property: 'TypePath',
                            value: 'Defect'
                        },
                        {
                            property: 'TypePath',
                            value: 'HierarchicalRequirement'
                        }
                    ];

                    this.down('#selector_box').add({
                        xtype: 'rallycombobox',
                        autoExpand: true,
                        itemId: 'cb-artifact-type',
                        storeConfig: {
                            model: 'TypeDefinition',
                            filters: Rally.data.wsapi.Filter.or(objTypeFilters),
                            autoLoad: true
                        },
                        displayField: 'DisplayName',
                        valueField: 'TypePath',
                        fieldLabel: 'Artifact Type',
                        labelAlign: 'right',
                        minWidth: 300,
                        labelWidth: 100,
                        margin: 10,
                        listeners: {
                            scope: this,
                            ready: this._updateFieldPicker,
                            select: this._updateFieldPicker
                        }
                    });
                },
                _updateFieldPicker: function (cb) {
                    var type = this._getArtifactType();

                    if (this.down('#cb-field')) {
                        this.down('#cb-field').destroy();
                        this.down('#bt-update').destroy();
                        this.down('#bt-export').destroy();
                    }

                    this.down('#selector_box').add({
                        xtype: 'tsdropdownfieldcombobox',
                        itemId: 'cb-field',
                        margin: 10,
                        fieldLabel: 'Field',
                        minWidth: 225,
                        labelWidth: 50,
                        labelAlign: 'right',
                        model: type
                    });

                    this.down('#selector_box').add({
                        xtype: 'rallybutton',
                        itemId: 'bt-update',
                        scope: this,
                        text: 'Update',
                        margin: 10,
                        handler: this._updateApp
                    });

                    this.down('#selector_box').add({
                        xtype: 'rallybutton',
                        itemId: 'bt-export',
                        scope: this,
                        text: 'Export',
                        disabled: true,
                        margin: 10,
                        handler: this._export
                    });
                },
                /********************************************
                 /* Overrides for App class
                 /*
                 /********************************************/
                //getSettingsFields:  Override for App
                getSettingsFields: function () {
                    var me = this;

                    return [{
                        name: 'threshhold',
                        xtype: 'rallynumberfield',
                        fieldLabel: 'Kickback threshold (seconds)',
                        labelWidth: 200,
                        labelAlign: 'right',
                        minValue: 0
                    }];
                },
                isExternal: function () {
                    return typeof (this.getAppId()) == 'undefined';
                },
                //showSettings:  Override
                showSettings: function (options) {
                    this._appSettings = Ext.create('Rally.app.AppSettings', Ext.apply({
                        fields: this.getSettingsFields(),
                        settings: this.getSettings(),
                        defaultSettings: this.getDefaultSettings(),
                        context: this.getContext(),
                        settingsScope: this.settingsScope,
                        autoScroll: true
                    }, options));

                    this._appSettings.on('cancel', this._hideSettings, this);
                    this._appSettings.on('save', this._onSettingsSaved, this);
                    if (this.isExternal()) {
                        if (this.down('#settings_box').getComponent(this._appSettings.id) ==
                            undefined) {
                            this.down('#settings_box').add(this._appSettings);
                        }
                    } else {
                        this.hide();
                        this.up().add(this._appSettings);
                    }
                    return this._appSettings;
                },
                _onSettingsSaved: function (settings) {
                    Ext.apply(this.settings, settings);
                    this._hideSettings();
                    this.onSettingsUpdate(settings);
                },
                //onSettingsUpdate:  Override
                onSettingsUpdate: function (settings) {
                    this.logger.log('onSettingsUpdate', settings);
                    Ext.apply(this, settings);
                    this._addComponents();
                }
            });


            Rally.launchApp('kickbacks-app', {
                name: 'Kickbacks and Deletions'
            });
        });
    </script>

    <style type="text/css">
        .app {}

        .tsinfolink {
            position: absolute;
            right: 0px;
            width: 14px;
            height: 14px;
            border-radius: 7px;
            text-align: center;
            color: white;
            background: #C0C0C0;
            border-style: solid;
            border-width: 1px;
            margin-top: 25px;
            margin-right: 5px;
            cursor: pointer;
        }
    </style>

</head>

<body></body>

</html>