<!DOCTYPE html>
<html>

<head>
    <title>Blocked Artifact History</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Thu Feb 04 2016 08:25:49 GMT-0700 (MST) -->

    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Feb 04 2016 08:25:49 GMT-0700 (MST)";
        var CHECKSUM = 56433227856;

    </script>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {

            /* Blob.js
             * A Blob implementation.
             * 2014-05-31
             *
             * By Eli Grey, http://eligrey.com
             * By Devin Samarin, https://github.com/eboyjr
             * License: X11/MIT
             *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
             */

            /*global self, unescape */
            /*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
             plusplus: true */

            /*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

            (function(view) {
                "use strict";

                view.URL = view.URL || view.webkitURL;

                if (view.Blob && view.URL) {
                    try {
                        new Blob;
                        return;
                    } catch (e) {}
                }

                // Internally we use a BlobBuilder implementation to base Blob off of
                // in order to support older browsers that only have BlobBuilder
                var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {
                    var
                        get_class = function(object) {
                            return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
                        },
                        FakeBlobBuilder = function BlobBuilder() {
                            this.data = [];
                        },
                        FakeBlob = function Blob(data, type, encoding) {
                            this.data = data;
                            this.size = data.length;
                            this.type = type;
                            this.encoding = encoding;
                        },
                        FBB_proto = FakeBlobBuilder.prototype,
                        FB_proto = FakeBlob.prototype,
                        FileReaderSync = view.FileReaderSync,
                        FileException = function(type) {
                            this.code = this[this.name = type];
                        },
                        file_ex_codes = (
                            "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR " +
                            "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
                        ).split(" "),
                        file_ex_code = file_ex_codes.length,
                        real_URL = view.URL || view.webkitURL || view,
                        real_create_object_URL = real_URL.createObjectURL,
                        real_revoke_object_URL = real_URL.revokeObjectURL,
                        URL = real_URL,
                        btoa = view.btoa,
                        atob = view.atob

                        ,
                        ArrayBuffer = view.ArrayBuffer,
                        Uint8Array = view.Uint8Array;
                    FakeBlob.fake = FB_proto.fake = true;
                    while (file_ex_code--) {
                        FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
                    }
                    if (!real_URL.createObjectURL) {
                        URL = view.URL = {};
                    }
                    URL.createObjectURL = function(blob) {
                        var
                            type = blob.type,
                            data_URI_header;
                        if (type === null) {
                            type = "application/octet-stream";
                        }
                        if (blob instanceof FakeBlob) {
                            data_URI_header = "data:" + type;
                            if (blob.encoding === "base64") {
                                return data_URI_header + ";base64," + blob.data;
                            } else if (blob.encoding === "URI") {
                                return data_URI_header + "," + decodeURIComponent(blob.data);
                            }
                            if (btoa) {
                                return data_URI_header + ";base64," + btoa(blob.data);
                            } else {
                                return data_URI_header + "," + encodeURIComponent(blob.data);
                            }
                        } else if (real_create_object_URL) {
                            return real_create_object_URL.call(real_URL, blob);
                        }
                    };
                    URL.revokeObjectURL = function(object_URL) {
                        if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
                            real_revoke_object_URL.call(real_URL, object_URL);
                        }
                    };
                    FBB_proto.append = function(data /*, endings*/ ) {
                        var bb = this.data;
                        // decode data to a binary string
                        if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
                            var
                                str = "",
                                buf = new Uint8Array(data),
                                i = 0,
                                buf_len = buf.length;
                            for (; i < buf_len; i++) {
                                str += String.fromCharCode(buf[i]);
                            }
                            bb.push(str);
                        } else if (get_class(data) === "Blob" || get_class(data) === "File") {
                            if (FileReaderSync) {
                                var fr = new FileReaderSync;
                                bb.push(fr.readAsBinaryString(data));
                            } else {
                                // async FileReader won't work as BlobBuilder is sync
                                throw new FileException("NOT_READABLE_ERR");
                            }
                        } else if (data instanceof FakeBlob) {
                            if (data.encoding === "base64" && atob) {
                                bb.push(atob(data.data));
                            } else if (data.encoding === "URI") {
                                bb.push(decodeURIComponent(data.data));
                            } else if (data.encoding === "raw") {
                                bb.push(data.data);
                            }
                        } else {
                            if (typeof data !== "string") {
                                data += ""; // convert unsupported types to strings
                            }
                            // decode UTF-16 to binary string
                            bb.push(unescape(encodeURIComponent(data)));
                        }
                    };
                    FBB_proto.getBlob = function(type) {
                        if (!arguments.length) {
                            type = null;
                        }
                        return new FakeBlob(this.data.join(""), type, "raw");
                    };
                    FBB_proto.toString = function() {
                        return "[object BlobBuilder]";
                    };
                    FB_proto.slice = function(start, end, type) {
                        var args = arguments.length;
                        if (args < 3) {
                            type = null;
                        }
                        return new FakeBlob(
                            this.data.slice(start, args > 1 ? end : this.data.length), type, this.encoding
                        );
                    };
                    FB_proto.toString = function() {
                        return "[object Blob]";
                    };
                    FB_proto.close = function() {
                        this.size = 0;
                        delete this.data;
                    };
                    return FakeBlobBuilder;
                }(view));

                view.Blob = function Blob(blobParts, options) {
                    var type = options ? (options.type || "") : "";
                    var builder = new BlobBuilder();
                    if (blobParts) {
                        for (var i = 0, len = blobParts.length; i < len; i++) {
                            builder.append(blobParts[i]);
                        }
                    }
                    return builder.getBlob(type);
                };
            }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));

            /* FileSaver.js
             *  A saveAs() FileSaver implementation.
             *  2014-05-27
             *
             *  By Eli Grey, http://eligrey.com
             *  License: X11/MIT
             *    See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
             */

            /*global self */
            /*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

            /*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

            var saveAs = saveAs
                // IE 10+ (native saveAs)
                ||
                (typeof navigator !== "undefined" &&
                    navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
                // Everyone else
                ||
                (function(view) {
                    "use strict";
                    // IE <10 is explicitly unsupported
                    if (typeof navigator !== "undefined" &&
                        /MSIE [1-9]\./.test(navigator.userAgent)) {
                        return;
                    }
                    var
                        doc = view.document
                        // only get URL when necessary in case Blob.js hasn't overridden it yet
                        ,
                        get_URL = function() {
                            return view.URL || view.webkitURL || view;
                        },
                        save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
                        can_use_save_link = !view.externalHost && "download" in save_link,
                        click = function(node) {
                            var event = doc.createEvent("MouseEvents");
                            event.initMouseEvent(
                                "click", true, false, view, 0, 0, 0, 0, 0, false, false, false, false, 0, null
                            );
                            node.dispatchEvent(event);
                        },
                        webkit_req_fs = view.webkitRequestFileSystem,
                        req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem,
                        throw_outside = function(ex) {
                            (view.setImmediate || view.setTimeout)(function() {
                                throw ex;
                            }, 0);
                        },
                        force_saveable_type = "application/octet-stream",
                        fs_min_size = 0,
                        deletion_queue = [],
                        process_deletion_queue = function() {
                            var i = deletion_queue.length;
                            while (i--) {
                                var file = deletion_queue[i];
                                if (typeof file === "string") { // file is an object URL
                                    get_URL().revokeObjectURL(file);
                                } else { // file is a File
                                    file.remove();
                                }
                            }
                            deletion_queue.length = 0; // clear queue
                        },
                        dispatch = function(filesaver, event_types, event) {
                            event_types = [].concat(event_types);
                            var i = event_types.length;
                            while (i--) {
                                var listener = filesaver["on" + event_types[i]];
                                if (typeof listener === "function") {
                                    try {
                                        listener.call(filesaver, event || filesaver);
                                    } catch (ex) {
                                        throw_outside(ex);
                                    }
                                }
                            }
                        },
                        FileSaver = function(blob, name) {
                            // First try a.download, then web filesystem, then object URLs
                            var
                                filesaver = this,
                                type = blob.type,
                                blob_changed = false,
                                object_url, target_view, get_object_url = function() {
                                    var object_url = get_URL().createObjectURL(blob);
                                    deletion_queue.push(object_url);
                                    return object_url;
                                },
                                dispatch_all = function() {
                                    dispatch(filesaver, "writestart progress write writeend".split(" "));
                                }
                                // on any filesys errors revert to saving with object URLs
                                ,
                                fs_error = function() {
                                    // don't create more object URLs than needed
                                    if (blob_changed || !object_url) {
                                        object_url = get_object_url(blob);
                                    }
                                    if (target_view) {
                                        target_view.location.href = object_url;
                                    } else {
                                        window.open(object_url, "_blank");
                                    }
                                    filesaver.readyState = filesaver.DONE;
                                    dispatch_all();
                                },
                                abortable = function(func) {
                                    return function() {
                                        if (filesaver.readyState !== filesaver.DONE) {
                                            return func.apply(this, arguments);
                                        }
                                    };
                                },
                                create_if_not_found = {
                                    create: true,
                                    exclusive: false
                                },
                                slice;
                            filesaver.readyState = filesaver.INIT;
                            if (!name) {
                                name = "download";
                            }
                            if (can_use_save_link) {
                                object_url = get_object_url(blob);
                                save_link.href = object_url;
                                save_link.download = name;
                                click(save_link);
                                filesaver.readyState = filesaver.DONE;
                                dispatch_all();
                                return;
                            }
                            // Object and web filesystem URLs have a problem saving in Google Chrome when
                            // viewed in a tab, so I force save with application/octet-stream
                            // http://code.google.com/p/chromium/issues/detail?id=91158
                            if (view.chrome && type && type !== force_saveable_type) {
                                slice = blob.slice || blob.webkitSlice;
                                blob = slice.call(blob, 0, blob.size, force_saveable_type);
                                blob_changed = true;
                            }
                            // Since I can't be sure that the guessed media type will trigger a download
                            // in WebKit, I append .download to the filename.
                            // https://bugs.webkit.org/show_bug.cgi?id=65440
                            if (webkit_req_fs && name !== "download") {
                                name += ".download";
                            }
                            if (type === force_saveable_type || webkit_req_fs) {
                                target_view = view;
                            }
                            if (!req_fs) {
                                fs_error();
                                return;
                            }
                            fs_min_size += blob.size;
                            req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
                                fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
                                    var save = function() {
                                        dir.getFile(name, create_if_not_found, abortable(function(file) {
                                            file.createWriter(abortable(function(writer) {
                                                writer.onwriteend = function(event) {
                                                    target_view.location.href = file.toURL();
                                                    deletion_queue.push(file);
                                                    filesaver.readyState = filesaver.DONE;
                                                    dispatch(filesaver, "writeend", event);
                                                };
                                                writer.onerror = function() {
                                                    var error = writer.error;
                                                    if (error.code !== error.ABORT_ERR) {
                                                        fs_error();
                                                    }
                                                };
                                                "writestart progress write abort".split(" ").forEach(function(event) {
                                                    writer["on" + event] = filesaver["on" + event];
                                                });
                                                writer.write(blob);
                                                filesaver.abort = function() {
                                                    writer.abort();
                                                    filesaver.readyState = filesaver.DONE;
                                                };
                                                filesaver.readyState = filesaver.WRITING;
                                            }), fs_error);
                                        }), fs_error);
                                    };
                                    dir.getFile(name, {
                                        create: false
                                    }, abortable(function(file) {
                                        // delete file if it already exists
                                        file.remove();
                                        save();
                                    }), abortable(function(ex) {
                                        if (ex.code === ex.NOT_FOUND_ERR) {
                                            save();
                                        } else {
                                            fs_error();
                                        }
                                    }));
                                }), fs_error);
                            }), fs_error);
                        },
                        FS_proto = FileSaver.prototype,
                        saveAs = function(blob, name) {
                            return new FileSaver(blob, name);
                        };
                    FS_proto.abort = function() {
                        var filesaver = this;
                        filesaver.readyState = filesaver.DONE;
                        dispatch(filesaver, "abort");
                    };
                    FS_proto.readyState = FS_proto.INIT = 0;
                    FS_proto.WRITING = 1;
                    FS_proto.DONE = 2;

                    FS_proto.error =
                        FS_proto.onwritestart =
                        FS_proto.onprogress =
                        FS_proto.onwrite =
                        FS_proto.onabort =
                        FS_proto.onerror =
                        FS_proto.onwriteend =
                        null;

                    view.addEventListener("unload", process_deletion_queue, false);
                    saveAs.unload = function() {
                        process_deletion_queue();
                        view.removeEventListener("unload", process_deletion_queue, false);
                    };
                    return saveAs;
                }(
                    typeof self !== "undefined" && self ||
                    typeof window !== "undefined" && window ||
                    this.content
                ));
            // `self` is undefined in Firefox for Android content script context
            // while `this` is nsIContentFrameMessageManager
            // with an attribute `content` that corresponds to the window

            if (typeof module !== "undefined" && module !== null) {
                module.exports = saveAs;
            } else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
                define([], function() {
                    return saveAs;
                });
            }
            /**
             * A link that pops up a version dialog box
             */

            Ext.define('Rally.technicalservices.InfoLink', {
                extend: 'Ext.Component',
                alias: 'widget.tsinfolink',

                /**
                 * @cfg {String} informationHtml
                 * Additional text to be displayed on the popup dialog (for exmaple,
                 * to add a description of the app's use or functionality)
                 */
                informationHtml: null,

                /**
                 * 
                 * cfg {String} title
                 * The title for the dialog box
                 */
                title: "Build Information",

                renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

                initComponent: function() {
                    this.callParent(arguments);

                },

                onRender: function() {
                    this.callParent(arguments);
                    this.mon(this.el, 'click', this.onClick, this);
                },
                _generateChecksum: function(string) {
                    var chk = 0x12345678,
                        i;
                    string = string.replace(/var CHECKSUM = .*;/, "");
                    string = string.replace(/\s/g, ""); //Remove all whitespace from the string.

                    for (i = 0; i < string.length; i++) {
                        chk += (string.charCodeAt(i) * i);
                    }

                    return chk;
                },
                _checkChecksum: function(container) {
                    var me = this;
                    Ext.Ajax.request({
                        url: document.URL,
                        params: {
                            id: 1
                        },
                        success: function(response) {
                            text = response.responseText;
                            if (CHECKSUM) {
                                if (CHECKSUM !== me._generateChecksum(text)) {
                                    console.log("Checksums don't match!");
                                    if (me.dialog) {
                                        me.dialog.add({
                                            xtype: 'container',
                                            html: 'Checksums do not match'
                                        });
                                    }
                                }
                            }
                        }
                    });
                },
                onClick: function(e) {
                    var me = this;
                    this._checkChecksum(this);

                    var dialog_items = [];

                    if (this.informationHtml) {
                        dialog_items.push({
                            xtype: 'container',
                            html: this.informationHtml
                        });
                    }

                    dialog_items.push({
                        xtype: 'container',
                        html: "This app was created by the Rally Technical Services Team."
                    });

                    if (APP_BUILD_DATE) {
                        dialog_items.push({
                            xtype: 'container',
                            html: 'Build date/time: ' + APP_BUILD_DATE
                        });
                    }

                    if (this.dialog) {
                        this.dialog.destroy();
                    }
                    this.dialog = Ext.create('Rally.ui.dialog.Dialog', {
                        defaults: {
                            padding: 5,
                            margin: 5
                        },
                        closable: true,
                        draggable: true,
                        title: me.title,
                        items: dialog_items
                    });
                    this.dialog.show();
                }
            });

            /*
             */
            Ext.define('Rally.technicalservices.Logger', {
                constructor: function(config) {
                    Ext.apply(this, config);
                },
                log: function(args) {
                    var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
                    //var output_args = arguments;
                    //output_args.unshift( [ "[ " + timestamp + " ]" ] );
                    //output_args = Ext.Array.push(output_args,arguments);

                    var output_args = [];
                    output_args = Ext.Array.push(output_args, [timestamp]);
                    output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments, 0));

                    window.console && console.log.apply(console, output_args);
                }

            });

            Ext.define('Rally.technicalservices.BlockedToolbox', {
                singleton: true,
                /**
                 * getBlockedDurations
                 *
                 * Returns an array of objects that represent one blocked duration for an artifact and include the following properties:
                 *     FormattedID
                 *     Name
                 *     DateBlocked
                 *     DateUnblocked
                 *     BlockedReason
                 *
                 * Assumes the minimal fetch list:
                 *     Name
                 *     FormattedID
                 *     _ValidFrom
                 *     Blocked
                 *     BlockedReason
                 *     _PreviousValues.Blocked
                 *     _PreviousValues.BlockedReason
                 *
                 * Also assumes snapshots are sorted by _ValidFrom in ascending order
                 *
                 */
                getBlockedDurations: function(snaps_by_oid) {

                    var data = [];

                    Ext.Object.each(snaps_by_oid, function(oid, snaps) {

                        var last_blocked_time = null;
                        var data_record = {
                            FormattedID: null,
                            Name: null,
                            BlockedReason: null,
                            BlockedDate: null,
                            UnblockedDate: null
                        };

                        Ext.each(snaps, function(snap) {
                            data_record.FormattedID = snap.FormattedID;
                            data_record.Name = snap.Name;
                            data_record.Feature = snap.Feature;
                            data_record.Project = snap.Project;
                            data_record.c_BlockerOwnerFirstLast = snap.c_BlockerOwnerFirstLast;
                            data_record.c_BlockerCategory = snap.c_BlockerCategory;
                            data_record.c_BlockerCreationDate = c_BlockerCreationDate;
                            var is_blocked = snap.Blocked;
                            var was_blocked = is_blocked;
                            if (snap._PreviousValues && (snap._PreviousValues.Blocked != undefined)) {
                                was_blocked = snap._PreviousValues.Blocked;
                            } else if (snap["_PreviousValues.Blocked"] != null) {
                                was_blocked = snap["_PreviousValues.Blocked"];
                            }

                            var reason = snap.BlockedReason || '';

                            var prev_reason = '';
                            if (snap._PreviousValues && (snap._PreviousValues.BlockedReason != undefined)) {
                                prev_reason = snap._PreviousValues.BlockedReason;
                            } else if (snap["_PreviousValues.BlockedReason"]) {
                                prev_reason = snap["_PreviousValues.BlockedReason"];
                            }

                            var date = Rally.util.DateTime.fromIsoString(snap._ValidFrom);
                            if (was_blocked && (is_blocked == false)) {
                                data_record.UnblockedDate = date;
                                data_record.BlockedReason = prev_reason;
                                data.push(data_record); //We push this here so that we can start a new one.
                                data_record = {
                                    FormattedID: snap.FormattedID,
                                    Name: snap.Name,
                                    BlockedReason: null,
                                    BlockedDate: null,
                                    UnblockedDate: null
                                };
                                last_blocked_time = null;
                            }

                            if (is_blocked && (was_blocked == false)) {
                                last_blocked_time = date;
                            }
                            if (is_blocked && reason.length > 0 && last_blocked_time) {
                                data_record.BlockedReason = reason;
                                data_record.BlockedDate = last_blocked_time;
                            }
                        }, this);

                        if (data_record.BlockedDate && data_record.UnblockedDate == null) {
                            data.push(data_record);
                        }
                    }, this);
                    return data;
                },
                getCountsByReason: function(snaps_by_oid) {
                    var counts = {};
                    var data = [];
                    Ext.Object.each(snaps_by_oid, function(oid, snaps) {
                        var rec = {
                            FormattedID: null,
                            Name: null,
                            BlockedReason: null
                        };
                        Ext.each(snaps, function(snap) {
                            rec.Name = snap.Name;
                            rec.FormattedID = snap.FormattedID;
                            if (snap.BlockedReason) {
                                if (counts[snap.BlockedReason] == undefined) {
                                    counts[snap.BlockedReason] = 0;
                                }
                                rec.BlockedReason = snap.BlockedReason;
                                counts[snap.BlockedReason]++;
                            }
                        });
                        data.push(rec);
                    }, this);
                    return {
                        counts: counts,
                        data: data
                    };
                },
                bucketDataByDate: function(artifacts, artifactProperty, dateInterval, dateFormat, bucketedDateStrings) {
                    var buckets = {};

                    Ext.each(bucketedDateStrings, function(str) {
                        buckets[str] = 0;
                    });

                    Ext.Object.each(artifacts, function(key, artifact) {
                        if (artifact[artifactProperty]) {
                            var date = Rally.util.DateTime.fromIsoString(artifact[artifactProperty]);
                            var bucket = Rally.util.DateTime.format(date, dateFormat);
                            if (Ext.Array.contains(bucketedDateStrings, bucket)) {
                                buckets[bucket]++;
                            }
                        }
                    });

                    return buckets;
                },
                aggregateBlockedTimelines: function(snaps_by_oid) {
                    var export_data = [];
                    var reason_data = {};

                    //Assumption is that these snaps are still sorted by _ValidFrom in ascending order for each oid
                    var block_action = {};

                    Ext.Object.each(snaps_by_oid, function(oid, snaps) {
                        var last_blocked_date = null;
                        var blocked_actions = [];
                        var formatted_id = snaps[0].get('FormattedID');

                        Ext.each(snaps, function(snap) {
                            var name = snap.get('Name');
                            var reason = snap.get('BlockedReason') || null;
                            var previous_reason = snap.get('_PreviousValues.BlockedReason') || null;
                            var blocked = snap.get('Blocked');
                            var was_blocked = snap.get('_PreviousValues.Blocked');
                            var date = Rally.util.DateTime.fromIsoString(snap.get('_ValidFrom'));

                            var rec = {
                                FormattedID: formatted_id,
                                BlockedDate: null,
                                UnblockedDate: null,
                                BlockedReason: null
                            };
                            if (blocked === true && was_blocked === false) {
                                //Transition to blocked
                                last_blocked_date = date;
                                rec.BlockedDate = last_blocked_date;
                                rec.BlockedReason = reason;
                                rec.Name = name;
                                blocked_actions.push(rec);
                            }

                            if (was_blocked === true && blocked === false) {
                                //Transition from blocked
                                var rec_found = false;
                                var idx = -1;
                                for (var i = 0; i < blocked_actions.length; i++) {
                                    if (blocked_actions[i].BlockedDate == last_blocked_date) {
                                        idx = i;
                                    }
                                }

                                if (idx < 0) {
                                    idx = blocked_actions.length;
                                    blocked_actions.push(rec);
                                }
                                blocked_actions[idx].Name = name;
                                blocked_actions[idx].UnblockedDate = date;
                                blocked_actions[idx].BlockedReason = previous_reason;
                                last_blocked_date = null;
                            }
                        });
                        block_action[formatted_id] = blocked_actions;
                    });
                    return block_action
                }
            });

            Ext.define('AgingCalculator', {
                singleton: true,
                getFieldHash: function(snapsForOid, arrayOfFields) {
                    var fieldHash = {};
                    Ext.each(snapsForOid, function(snap) {
                        Ext.each(arrayOfFields, function(f) {
                            var snapVal = snap[f];
                            var currentVal = fieldHash[f] || '';
                            fieldHash[f] = snapVal;
                        });
                    });
                    return fieldHash;
                },
                getFieldCurrentValue: function(snapsForOid, field) {
                    return snapsForOid[snapsForOid.length - 1][field];
                },
                calculateMobility: function(snapsForOid, previousValueField, currentField, fieldValue, mobilityField) {
                    var startValue = null;
                    var currentValue = null;
                    if (snapsForOid.length > 0) {
                        var previousValue = snapsForOid[0][currentField];
                        var previousValueField = "_PreviousValues." + currentField;
                        if (snapsForOid[0][previousValueField] != undefined) {
                            previousValue = snapsForOid[0][previousValueField];
                        }

                        Ext.each(snapsForOid, function(snap) {
                            if (snap[currentField] != previousValue) {
                                if (snap[currentField] === fieldValue) {
                                    startValue = snap[mobilityField];
                                }
                            }
                            previousValue = snap[currentField];
                        }, this);

                        currentValue = snapsForOid[snapsForOid.length - 1][mobilityField];
                    }
                    return {
                        startValue: startValue,
                        currentValue: currentValue
                    }
                },
                calculateDurations: function(snapsForOid, currentField, fieldValue, blockedAfterDate) {
                    var granularity = "hour";
                    var conversionDivisor = 24;
                    var threshhold = 24;
                    var ages = [];
                    var earliestStartDate = null;
                    var lastEndDate = null;

                    if (snapsForOid.length > 0) {
                        var startDate = null;
                        var endDate = Rally.util.DateTime.fromIsoString(snapsForOid[0]._ValidFrom);
                        if (blockedAfterDate == undefined || blockedAfterDate == null) {
                            blockedAfterDate = Rally.util.DateTime.fromIsoString(snapsForOid[0]._ValidFrom);
                        }

                        var previousValue = snapsForOid[0][currentField];
                        var previousValueField = "_PreviousValues." + currentField;
                        if (snapsForOid[0][previousValueField] != undefined) {
                            previousValue = snapsForOid[0][previousValueField];
                        } else {
                            previousValue = false;
                        }
                        var isCurrent = false;
                        Ext.each(snapsForOid, function(snap) {
                            if (snap[currentField] != previousValue) {
                                var date = Rally.util.DateTime.fromIsoString(snap._ValidFrom);
                                if (snap[currentField] === fieldValue && date >= blockedAfterDate) {
                                    startDate = date;
                                    if (earliestStartDate == null) {
                                        earliestStartDate = date;
                                    }
                                }
                                if (startDate && previousValue === fieldValue) {
                                    lastEndDate = date;
                                    var diff = Rally.util.DateTime.getDifference(date, startDate, granularity);
                                    if (diff >= threshhold) {
                                        ages.push(diff / conversionDivisor);
                                    }
                                    startDate = null;
                                }
                            }
                            previousValue = snap[currentField];
                            if (Rally.util.DateTime.fromIsoString(snap._ValidTo) > new Date()) {
                                isCurrent = true;
                            }
                        }, this);

                        if (startDate != null && isCurrent) {
                            var diff = Rally.util.DateTime.getDifference(new Date(), startDate, granularity);
                            if (diff >= threshhold) {
                                ages.push(diff / conversionDivisor);
                            }
                        }
                    }
                    return {
                        durations: ages,
                        earliestStartDate: earliestStartDate,
                        lastEndDate: lastEndDate
                    };
                }

            });

            Ext.define('Rally.technicalservices.FileUtilities', {
                singleton: true,
                logger: new Rally.technicalservices.Logger(),
                saveCSVToFile: function(csv, file_name, type_object) {
                    if (type_object == undefined) {
                        type_object = {
                            type: 'text/csv;charset=utf-8'
                        };
                    }
                    var blob = new Blob([csv], type_object);
                    saveAs(blob, file_name);
                },

                saveTextAsFile: function(textToWrite, fileName, options) {
                    var options = Ext.merge({
                        type: 'text/plain'
                    }, options);
                    console.log(options);
                    var textFileAsBlob = new Blob([textToWrite], options);
                    var fileNameToSaveAs = fileName;

                    var downloadLink = document.createElement("a");
                    downloadLink.download = fileNameToSaveAs;
                    downloadLink.innerHTML = "Download File";
                    if (window.webkitURL != null) {
                        // Chrome allows the link to be clicked
                        // without actually adding it to the DOM.
                        downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
                    } else {
                        // Firefox requires the link to be added to the DOM
                        // before it can be clicked.
                        downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
                        downloadLink.onclick = this.destroyClickedElement;
                        downloadLink.style.display = "none";
                        document.body.appendChild(downloadLink);
                    }
                    downloadLink.click();
                },
                destroyClickedElement: function(event) {
                    document.body.removeChild(event.target);
                },
                convertDataArrayToCSVText: function(data_array, requestedFieldHash) {

                    var text = '';
                    Ext.each(Object.keys(requestedFieldHash), function(key) {
                        text += requestedFieldHash[key] + ',';
                    });
                    text = text.replace(/,$/, '\n');

                    Ext.each(data_array, function(d) {
                        Ext.each(Object.keys(requestedFieldHash), function(key) {
                            if (d[key]) {
                                if (typeof d[key] === 'object') {
                                    if (d[key].FormattedID) {
                                        text += Ext.String.format("\"{0}\",", d[key].FormattedID);
                                    } else if (d[key].Name) {
                                        text += Ext.String.format("\"{0}\",", d[key].Name);
                                    } else if (!isNaN(Date.parse(d[key]))) {
                                        text += Ext.String.format("\"{0}\",", Rally.util.DateTime.formatWithDefaultDateTime(d[key]));
                                    } else {
                                        text += Ext.String.format("\"{0}\",", d[key].toString());
                                    }
                                } else {
                                    text += Ext.String.format("\"{0}\",", d[key]);
                                }
                            } else {
                                text += ',';
                            }
                        }, this);
                        text = text.replace(/,$/, '\n');
                    }, this);
                    return text;
                },
                /*
                 * will render using your grid renderer.  If you want it to ignore the grid renderer,
                 * have the column set _csvIgnoreRender: true
                 */
                getCSVFromGrid: function(grid) {
                    var deferred = Ext.create('Deft.Deferred');
                    var store = grid.getStore();

                    var columns = grid.columns;
                    var column_names = [];
                    var headers = [];

                    var csv = [];

                    Ext.Array.each(columns, function(column) {
                        if (column.dataIndex || column.renderer) {
                            column_names.push(column.dataIndex);
                            if (column.csvText) {
                                headers.push(column.csvText);
                            } else {
                                headers.push(column.text);
                            }
                        }
                    });

                    csv.push('"' + headers.join('","') + '"');

                    var mock_meta_data = {
                        align: "right",
                        classes: [],
                        cellIndex: 9,
                        column: null,
                        columnIndex: 9,
                        innerCls: undefined,
                        recordIndex: 5,
                        rowIndex: 5,
                        style: "",
                        tdAttr: "",
                        tdCls: "x-grid-cell x-grid-td x-grid-cell-headerId-gridcolumn-1029 x-grid-cell-last x-unselectable",
                        unselectableAttr: "unselectable='on'"
                    }

                    for (var i = 0; i < store.getCount(); i++) {
                        var record = store.getAt(i);

                        var node_values = [];
                        Ext.Array.each(columns, function(column) {
                            if (column.dataIndex) {
                                var column_name = column.dataIndex;
                                var display_value = record.get(column_name);

                                if (!column._csvIgnoreRender && column.renderer) {
                                    display_value = column.renderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                                }
                                node_values.push(display_value);
                            } else {
                                var display_value = null;
                                if (!column._csvIgnoreRender && column.renderer) {
                                    display_value = column.renderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                                    node_values.push(display_value);
                                }
                            }
                        }, this);
                        csv.push('"' + node_values.join('","') + '"');
                    }
                    return csv.join('\r\n');
                }
            });

            Ext.override(Ext.data.proxy.Server, {
                timeout: 60000,
                processResponse: function(success, operation, request, response, callback, scope) {
                    var me = this,
                        reader,
                        result;

                    if (success === true) {
                        reader = me.getReader();
                        reader.applyDefaults = operation.action === 'read';
                        result = reader.read(me.extractResponseData(response));

                        if (result.success !== false) {

                            Ext.apply(operation, {
                                response: response,
                                resultSet: result
                            });

                            operation.commitRecords(result.records);
                            operation.setCompleted();
                            operation.setSuccessful();
                        } else {
                            operation.setException(result.message);
                            me.fireEvent('exception', this, response, operation);
                        }
                    } else {
                        if (response) {
                            me.setException(operation, response);
                        }
                        me.fireEvent('exception', this, response, operation);
                    }


                    if (typeof callback == 'function') {
                        callback.call(scope || me, operation);
                    }

                    me.afterRequest(request, success);
                },


                setException: function(operation, response) {
                    operation.setException({
                        status: response.status,
                        statusText: response.statusText
                    });
                },


                extractResponseData: Ext.identityFn,


                applyEncoding: function(value) {
                    return Ext.encode(value);
                },
            });
            Ext.define('Rally.technicalservices.Toolbox', {
                singleton: true,
                /**
                 * Returns beginnig of month as date for the current time zone
                 *
                 */
                getBeginningOfMonthAsDate: function(dateInMonth) {
                    var year = dateInMonth.getFullYear();
                    var month = dateInMonth.getMonth();
                    return new Date(year, month, 1, 0, 0, 0, 0);
                },
                getEndOfMonthAsDate: function(dateInMonth) {
                    var year = dateInMonth.getFullYear();
                    var month = dateInMonth.getMonth();
                    var day = new Date(year, month + 1, 0).getDate();
                    return new Date(year, month, day, 0, 0, 0, 0);
                },
                aggregateSnapsByOid: function(snaps) {
                    //Return a hash of objects (key=ObjectID) with all snapshots for the object
                    var snaps_by_oid = {};
                    Ext.each(snaps, function(snap) {
                        var oid = snap.ObjectID || snap.get('ObjectID');
                        if (snaps_by_oid[oid] == undefined) {
                            snaps_by_oid[oid] = [];
                        }
                        snaps_by_oid[oid].push(snap);

                    });
                    return snaps_by_oid;
                },
                getCaseInsensitiveKey: function(obj, inputStr) {
                    var new_key = inputStr;
                    Ext.Object.each(obj, function(key, val) {
                        if (new_key.toLowerCase() == key.toLowerCase()) {
                            new_key = key;
                        }
                    });
                    return new_key;

                },
                aggregateSnapsByOidForModel: function(snaps) {
                    //Return a hash of objects (key=ObjectID) with all snapshots for the object
                    var snaps_by_oid = {};
                    Ext.each(snaps, function(snap) {
                        var oid = snap.ObjectID || snap.get('ObjectID');
                        if (snaps_by_oid[oid] == undefined) {
                            snaps_by_oid[oid] = [];
                        }
                        snaps_by_oid[oid].push(snap.getData());

                    });
                    return snaps_by_oid;
                },
                getDateBuckets: function(startDate, endDate, granularity) {

                    var bucketStartDate = Rally.technicalservices.Toolbox.getBeginningOfMonthAsDate(startDate);
                    var bucketEndDate = Rally.technicalservices.Toolbox.getEndOfMonthAsDate(endDate);

                    var date = bucketStartDate;

                    var buckets = [];
                    while (date < bucketEndDate && bucketStartDate < bucketEndDate) {
                        buckets.push(date);
                        date = Rally.util.DateTime.add(date, granularity, 1);
                    }
                    return buckets;
                },
                formatDateBuckets: function(buckets, dateFormat) {
                    var categories = [];
                    Ext.each(buckets, function(bucket) {
                        categories.push(Rally.util.DateTime.format(bucket, dateFormat));
                    });
                    categories[categories.length - 1] += "*";
                    return categories;
                },
                getLinkByOid: function(objectType, objectId, linkText) {

                    var urlText = Ext.String.format("/{0}/{1}", objectType.toLowerCase(), objectId),
                        url = Rally.nav.Manager.getDetailUrl(urlText);

                    return Ext.String.format('<a href="{0}" target="_blank">{1}</a>', url, linkText);
                }

            });

            Ext.define('blocked-artifact-history', {
                extend: 'Rally.app.App',
                componentCls: 'app',
                logger: new Rally.technicalservices.Logger(),
                items: [{
                        xtype: 'container',
                        itemId: 'header_box',
                        layout: {
                            type: 'hbox'
                        },
                        items: [{
                                xtype: 'container',
                                itemId: 'control_box',
                                layout: {
                                    type: 'hbox'
                                }
                            },
                            {
                                xtype: 'container',
                                itemId: 'button_box',
                                layout: {
                                    type: 'hbox'
                                }
                            },
                            {
                                xtype: 'container',
                                itemId: 'summary_box',
                                padding: 10,
                                tpl: '<tpl><font color="grey"><b><i>{message}</i></b></color></tpl>'
                            },

                        ]
                    },
                    {
                        xtype: 'container',
                        itemId: 'display_box'
                    },
                    {
                        xtype: 'tsinfolink'
                    }
                ],
                invalidDateString: 'Invalid Date',
                dateFormat: 'MM/dd/YYYY',
                showOptionsStore: [
                    [true, "Current Blocked Items"],
                    [false, "Items Blocked on or after"]
                ],
                lookbackFetchFields: ['ObjectID', '_PreviousValues.Blocked', '_SnapshotNumber', 'Name', 'FormattedID', '_ProjectHierarchy', 'Feature', '_TypeHierarchy', 'Blocked', '_ValidFrom', '_ValidTo', 'BlockedReason', 'c_BlockerOwnerFirstLast', 'c_BlockerCategory', 'c_BlockerCreationDate', 'DirectChildrenCount', 'Feature', 'Iteration', 'ScheduleState'],
                featureHash: {},
                launch: function() {
                    var defaultDate = Rally.util.DateTime.add(new Date(), "month", -3);
                    this.down('#control_box').add({
                        xtype: 'rallycheckboxfield',
                        itemId: 'chk-blocked',
                        fieldLabel: 'Blocked Only',
                        labelAlign: 'right',
                        labelWidth: 100,
                        margin: 10,
                        listeners: {
                            scope: this,
                            change: function() {
                                this._filterBlocked();
                            }
                        }
                    });

                    this.down('#control_box').add({
                        xtype: 'rallydatefield',
                        itemId: 'from-date-picker',
                        fieldLabel: 'Items blocked on or after',
                        labelAlign: 'right',
                        labelWidth: 150,
                        value: defaultDate,
                        margin: 10,
                    });

                    this.down('#button_box').add({
                        xtype: 'rallybutton',
                        itemId: 'run-button',
                        text: 'Run',
                        margin: 10,
                        scope: this,
                        width: 75,
                        handler: this._run,
                    });

                    this.down('#button_box').add({
                        xtype: 'rallybutton',
                        itemId: 'export-button',
                        text: 'Export',
                        margin: 10,
                        scope: this,
                        width: 75,
                        handler: this._exportData,
                    });
                },
                _getFromDateControl: function() {
                    return this.down('#from-date-picker');
                },
                _getFromDate: function() {
                    if (this._getFromDateControl()) {
                        var fromDate = this._getFromDateControl().getValue();
                        if (!isNaN(Date.parse(fromDate))) {
                            return fromDate;
                        }
                    }
                    return null;
                },
                _filterBlocked: function(store) {
                    var filterBlocked = this._showOnlyBlockedItems();

                    if (store == undefined) {
                        var grid = this._getGrid();
                        if (grid == null) {
                            return;
                        }
                        store = grid.getStore();
                    }

                    if (filterBlocked === true) {
                        store.filterBy(function(item) {
                            return (item.get('Blocked') === true);
                        });
                    } else {
                        store.clearFilter();
                    }
                    this._updateSummary(store.count());
                },
                _updateSummary: function(totalResults) {
                    var blocked = '';
                    if (this._showOnlyBlockedItems()) {
                        blocked = "blocked"
                    }
                    var msg = Ext.String.format("{0} {1} items found.", totalResults, blocked);
                    this.down('#summary_box').update({
                        message: msg
                    });
                },
                _showOnlyBlockedItems: function() {
                    if (this.down('#chk-blocked')) {
                        this.logger.log('showOnlyBlockedItems ', this.down('#chk-blocked').getValue());
                        return this.down('#chk-blocked').getValue();
                    }
                    return false;
                },
                _run: function() {
                    var fromDate = this._getFromDate();
                    if (isNaN(Date.parse(fromDate))) {
                        Rally.ui.notify.Notifier.showWarning({
                            message: "No date selected.  Please select a date and try again."
                        });
                        return;
                    }
                    var current_project_id = this.getContext().getProject().ObjectID;

                    this.setLoading(true);
                    this._fetchLookbackStore(current_project_id, fromDate).then({
                        scope: this,
                        success: this._calculateAgingForBlockers
                    });
                },
                _fetchLookbackStore: function(currentProjectId, fromDate) {
                    var deferred = Ext.create('Deft.Deferred');

                    var find = {};
                    var isoFromDate = Rally.util.DateTime.toIsoString(fromDate);
                    find["_ValidTo"] = {
                        $gte: isoFromDate
                    };
                    find["$or"] = [{
                        "_PreviousValues.Blocked": true
                    }, {
                        "Blocked": true
                    }];
                    find["_TypeHierarchy"] = 'HierarchicalRequirement';
                    find["_ProjectHierarchy"] = currentProjectId;

                    Ext.create('Rally.data.lookback.SnapshotStore', {
                        scope: this,
                        listeners: {
                            scope: this,
                            load: function(store, data, success) {
                                this.logger.log('fetchLookbackStore load', data.length, success);
                                var snaps_by_oid = Rally.technicalservices.Toolbox.aggregateSnapsByOidForModel(data);
                                deferred.resolve(snaps_by_oid);
                            }
                        },
                        autoLoad: true,
                        fetch: this.lookbackFetchFields,
                        hydrate: ["Iteration", "Project", "ScheduleState"],
                        find: find,
                        sort: {
                            '_ValidFrom': 1
                        }
                    });
                    return deferred.promise;
                },
                _fetchFeatureHash: function() {
                    var deferred = Ext.create('Deft.Deferred');
                    var me = this;
                    me.logger.log('_fetchFeatureHash start');
                    Ext.create('Rally.data.lookback.SnapshotStore', {
                        scope: this,
                        listeners: {
                            scope: this,
                            load: function(store, data, success) {
                                me.logger.log('_fetchFeatureHash returned data', data);
                                Ext.each(data, function(d) {
                                    var key = d.get('ObjectID').toString();
                                    this.featureHash[key] = d.getData();
                                }, this);
                                deferred.resolve(data);
                            }
                        },
                        autoLoad: true,
                        fetch: ['Name', 'FormattedID', 'ObjectID'],
                        find: {
                            "_TypeHierarchy": "PortfolioItem/Feature",
                            "__At": "current"
                        }
                    });
                    return deferred.promise;
                },
                _renderGrid: function(data) {
                    var columns = [{
                            // xtype: 'templatecolumn',
                            text: 'FormattedID',
                            dataIndex: 'FormattedID',
                            renderer: function(v, m, r) {
                                var link_text = r.get('FormattedID');
                                if (v) {
                                    return Ext.String.format('<a href="{0}" target="_blank">{1}</a>', Rally.nav.Manager.getDetailUrl('/userstory/' + r.get('ObjectID')), link_text);
                                }
                            }
                        },
                        {
                            text: 'Name',
                            dataIndex: 'Name',
                            flex: 1
                        },
                        {
                            text: 'Project',
                            flex: 1,
                            dataIndex: 'Project',
                            renderer: this._objectNameRenderer
                        },
                        //    {text: 'Feature', dataIndex: 'Feature', renderer: this._featureOidRenderer},
                        {
                            text: 'Total Blocked Time (Days)',
                            dataIndex: 'totalBlocked',
                            renderer: this._decimalRenderer
                        }
                    ];
                    columns.push({
                        text: 'Average Resolution Time (Days)',
                        dataIndex: 'averageResolutionTime',
                        renderer: this._decimalRenderer
                    });
                    columns.push({
                        text: '#Durations',
                        dataIndex: 'numDurations'
                    });
                    columns.push({
                        text: 'Iteration Blocked In',
                        dataIndex: 'startValue',
                        renderer: this._iterationRenderer
                    });
                    columns.push({
                        text: 'Current Iteration',
                        dataIndex: 'currentValue',
                        renderer: this._iterationRenderer
                    });
                    columns.push({
                        text: 'Current Schedule State',
                        dataIndex: 'ScheduleState'
                    });
                    columns.push({
                        text: 'Currently Blocked',
                        dataIndex: 'Blocked',
                        renderer: this._yesNoRenderer
                    });
                    if (this.down('#data-grid')) {
                        this.down('#data-grid').destroy();
                    }

                    var pageSize = data.length;
                    var grid = Ext.create('Rally.ui.grid.Grid', {
                        itemId: 'data-grid',
                        store: Ext.create('Rally.data.custom.Store', {
                            data: data,
                            autoLoad: true,
                            remoteSort: false,
                            remoteFilter: false,
                            pageSize: pageSize,
                            scroll: 'vertical',
                            listeners: {
                                scope: this,
                                load: function(store) {
                                    this._filterBlocked(store);
                                }
                            }
                        }),
                        showPagingToolbar: false,
                        columnCfgs: columns

                    });
                    this.down('#display_box').add(grid);

                    this.setLoading(false);

                },
                _getGrid: function() {
                    return this.down('#data-grid');
                },
                _decimalRenderer: function(v, m, r) {
                    if (!isNaN(v)) {
                        return v.toFixed(1);
                    }
                    return v;
                },
                _yesNoRenderer: function(v, m, r) {
                    if (v === true) {
                        return 'Yes';
                    }
                    return 'No';
                },
                _featureOidRenderer: function(v, m, r) {
                    if (v && typeof v == 'object') {
                        return Ext.String.format('{0}: {1}', v.FormattedID, v.Name);
                    }
                    return v;
                },
                _objectNameRenderer: function(v, m, r) {
                    if (v && typeof v == 'object') {
                        return v.Name;
                    }
                    return v;
                },
                _iterationRenderer: function(v, m, r) {
                    if (v && typeof v == 'object') {
                        return v.Name;
                    }
                    return 'Unscheduled';
                },

                _calculateAgingForBlockers: function(snapsByOid) {
                    this.logger.log('_calculateAgingForBlockers', snapsByOid);
                    var desiredFields = ['ObjectID', 'FormattedID', 'Name', 'Feature', 'Project', 'BlockedReason', 'Blocked', 'ScheduleState'];
                    var data = [];
                    var fromDate = this._getFromDate() || null;

                    Ext.Object.each(snapsByOid, function(oid, snaps) {
                        var fieldObj = AgingCalculator.getFieldHash(snaps, desiredFields);
                        var agingObj = AgingCalculator.calculateDurations(snaps, "Blocked", true, fromDate);
                        var mobilityObj = AgingCalculator.calculateMobility(snaps, "_PreviousValues.Blocked", "Blocked", true, "Iteration");
                        var record = _.extend(fieldObj, mobilityObj);

                        this.logger.log(fieldObj, agingObj, mobilityObj);

                        record["numDurations"] = agingObj.durations.length;
                        if (agingObj.durations.length > 0) {
                            record["totalBlocked"] = Ext.Array.sum(agingObj.durations);
                            var mean_array = agingObj.durations;
                            record["averageResolutionTime"] = Ext.Array.mean(agingObj.durations);
                            data.push(record);
                        }
                    }, this);
                    this.logger.log('_calculateAgingForBlockers', data);

                    this._renderGrid(data);
                },
                _exportData: function() {
                    var filename = Ext.String.format('blockers-{0}.csv', Rally.util.DateTime.format(new Date(), 'Y-m-d'));
                    var csv = Rally.technicalservices.FileUtilities.getCSVFromGrid(this._getGrid());
                    this.logger.log('_exportData', filename, csv);
                    Rally.technicalservices.FileUtilities.saveCSVToFile(csv, filename);
                }
            });

            Rally.launchApp('blocked-artifact-history', {
                name: 'Blocked Artifact History'
            });
        });

    </script>

    <style type="text/css">
        .app {}

        .tsinfolink {
            position: absolute;
            right: 0px;
            width: 14px;
            height: 14px;
            border-radius: 7px;
            text-align: center;
            color: white;
            background: #C0C0C0;
            border-style: solid;
            border-width: 1px;
            margin-top: 25px;
            margin-right: 5px;
            cursor: pointer;
        }

    </style>

</head>

<body></body>

</html>
